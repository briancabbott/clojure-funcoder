<javax.xml.bind|Validator 48e4442f> As of JAXB 2.0, this class is deprecated and optional. 
<javax.xml.bind|Validator 6c748a4e> The Validator class is responsible for controlling the validation of content trees during runtime. 
<javax.xml.bind|Validator 1cebc95b> Three Forms of Validation Unmarshal-Time Validation This form of validation enables a client application to receive information about validation errors and warnings detected while unmarshalling XML data into a Java content tree and is completely orthogonal to the other types of validation. 
<javax.xml.bind|Validator 4feae1ec> To enable or disable it, see the javadoc for {@link Unmarshaller#setValidating(boolean) Unmarshaller.setValidating}. 
<javax.xml.bind|Validator 881912fb> All JAXB 1.0 Providers are required to support this operation. 
<javax.xml.bind|Validator 4d054255> On-Demand Validation This form of validation enables a client application to receive information about validation errors and warnings detected in the Java content tree. 
<javax.xml.bind|Validator cf2728ba> At any point, client applications can call the {@link Validator#validate(Object) Validator.validate} method on the Java content tree (or any sub-tree of it). 
<javax.xml.bind|Validator f5598ab5> Fail-Fast Validation This form of validation enables a client application to receive immediate feedback about modifications to the Java content tree that violate type constraints on Java Properties as defined in the specification. 
<javax.xml.bind|Validator 413e411f> JAXB Providers are not required support this type of validation. 
<javax.xml.bind|Validator 3e3b929b> Of the JAXB Providers that do support this type of validation, some may require you to decide at schema compile time whether or not a client application will be allowed to request fail-fast validation at runtime. 
<javax.xml.bind|Validator 3862e243> The Validator class is responsible for managing On-Demand Validation. 
<javax.xml.bind|Validator ef5adb71> The Unmarshaller class is responsible for managing Unmarshal-Time Validation during the unmarshal operations. 
<javax.xml.bind|Validator a5931afe> Although there is no formal method of enabling validation during the marshal operations, the Marshaller may detect errors, which will be reported to the ValidationEventHandler registered on it. 
<javax.xml.bind|Validator 3f645e1d> Using the Default EventHandler If the client application does not set an event handler on their Validator, Unmarshaller, or Marshaller prior to calling the validate, unmarshal, or marshal methods, then a default event handler will receive notification of any errors or warnings encountered. 
<javax.xml.bind|Validator 782c3a16> The default event handler will cause the current operation to halt after encountering the first error or fatal error (but will attempt to continue after receiving warnings). 
<javax.xml.bind|Validator 7ba8f72c> Handling Validation Events There are three ways to handle events encountered during the unmarshal, validate, and marshal operations: Use the default event handler The default event handler will be used if you do not specify one via the setEventHandler API's on Validator, Unmarshaller, or Marshaller. 
<javax.xml.bind|Validator e1465e98> Implement and register a custom event handler Client applications that require sophisticated event processing can implement the ValidationEventHandler interface and register it with the Unmarshaller and/or Validator. 
<javax.xml.bind|Validator ccaa4590> Use the {@link javax.xml.bind.util.ValidationEventCollector ValidationEventCollector} utility For convenience, a specialized event handler is provided that simply collects any ValidationEvent objects created during the unmarshal, validate, and marshal operations and returns them to the client application as a java.util.Collection. 
<javax.xml.bind|Validator e092b75c> Validation and Well-Formedness Validation events are handled differently depending on how the client application is configured to process them as described in the previous section. 
<javax.xml.bind|Validator 14a20cb7> However, there are certain cases where a JAXB Provider indicates that it is no longer able to reliably detect and report errors. 
<javax.xml.bind|Validator 4d96349f> In these cases, the JAXB Provider will set the severity of the ValidationEvent to FATAL_ERROR to indicate that the unmarshal, validate, or marshal operations should be terminated. 
<javax.xml.bind|Validator ac7279e0> The default event handler and ValidationEventCollector utility class must terminate processing after being notified of a fatal error. 
<javax.xml.bind|Validator bdc3ba98> Client applications that supply their own ValidationEventHandler should also terminate processing after being notified of a fatal error. 
<javax.xml.bind|Validator 5582eab> If not, unexpected behaviour may occur. 
<javax.xml.bind|Validator 98369ea2> Supported Properties There currently are not any properties required to be supported by all JAXB Providers on Validator. 
<javax.xml.bind|Validator 10551f47> However, some providers may support their own set of provider specific properties. 
<javax.xml.bind|Validator.setEventHandler(javax.xml.bind.ValidationEventHandler) 126e3720> Allow an application to register a validation event handler. 
<javax.xml.bind|Validator.setEventHandler(javax.xml.bind.ValidationEventHandler) 6b8c0a53> The validation event handler will be called by the JAXB Provider if any validation errors are encountered during calls to {@link #validate(Object) validate}. 
<javax.xml.bind|Validator.setEventHandler(javax.xml.bind.ValidationEventHandler) 56aa88c6> If the client application does not register a validation event handler before invoking the validate method, then validation events will be handled by the default event handler which will terminate the validate operation after the first error or fatal error is encountered. 
<javax.xml.bind|Validator.setEventHandler(javax.xml.bind.ValidationEventHandler) d435fea3> Calling this method with a null parameter will cause the Validator to revert back to the default default event handler. 
<javax.xml.bind|Validator.setEventHandler(javax.xml.bind.ValidationEventHandler) 778ea19b> @throws:JAXBException if an error was encountered while setting the event handler. 
<javax.xml.bind|Validator.getEventHandler() de7fd39f> Return the current event handler or the default event handler if one hasn't been set. 
<javax.xml.bind|Validator.getEventHandler() ef8f894b> @return:the current ValidationEventHandler or the default event handler if it hasn't been set. 
<javax.xml.bind|Validator.getEventHandler() 2fe6718a> @throws:JAXBException if an error was encountered while getting the current event handler. 
<javax.xml.bind|Validator.validate(java.lang.Object) b7e0ad6a> Validate the Java content tree starting at subrootObj. 
<javax.xml.bind|Validator.validate(java.lang.Object) fde1070c> Client applications can use this method to validate Java content trees on-demand at runtime. 
<javax.xml.bind|Validator.validate(java.lang.Object) 27de208> This method can be used to validate any arbitrary subtree of the Java content tree. 
<javax.xml.bind|Validator.validate(java.lang.Object) 51d3363c> Global constraint checking will not be performed as part of this operation (i.e. ID/IDREF constraints). 
<javax.xml.bind|Validator.validate(java.lang.Object) 3a7fd158> @throws:JAXBException if any unexpected problem occurs during validation. 
<javax.xml.bind|Validator.validate(java.lang.Object) a362fd60> @throws:ValidationException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Validator is unable to validate the content tree rooted at subrootObj. 
<javax.xml.bind|Validator.validate(java.lang.Object) 88bcc231> @throws:IllegalArgumentException If the subrootObj parameter is null. 
<javax.xml.bind|Validator.validate(java.lang.Object) d6420d3e> @return:true if the subtree rooted at subrootObj is valid, false otherwise. 
<javax.xml.bind|Validator.validateRoot(java.lang.Object) 8a78d7c3> Validate the Java content tree rooted at rootObj. 
<javax.xml.bind|Validator.validateRoot(java.lang.Object) fde1070c> Client applications can use this method to validate Java content trees on-demand at runtime. 
<javax.xml.bind|Validator.validateRoot(java.lang.Object) d77878cb> This method is used to validate an entire Java content tree. 
<javax.xml.bind|Validator.validateRoot(java.lang.Object) 679276f6> Global constraint checking will be performed as part of this operation (i.e. ID/IDREF constraints). 
<javax.xml.bind|Validator.validateRoot(java.lang.Object) 3a7fd158> @throws:JAXBException if any unexpected problem occurs during validation. 
<javax.xml.bind|Validator.validateRoot(java.lang.Object) 791c2451> @throws:ValidationException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Validator is unable to validate the content tree rooted at rootObj. 
<javax.xml.bind|Validator.validateRoot(java.lang.Object) ffa999a0> @throws:IllegalArgumentException If the rootObj parameter is null. 
<javax.xml.bind|Validator.validateRoot(java.lang.Object) 860a1ea0> @return:true if the tree rooted at rootObj is valid, false otherwise. 
<javax.xml.bind|Validator.setProperty(java.lang.String,java.lang.Object) f4ec4fdf> Set the particular property in the underlying implementation of Validator. 
<javax.xml.bind|Validator.setProperty(java.lang.String,java.lang.Object) 33bae51e> This method can only be used to set one of the standard JAXB defined properties above or a provider specific property. 
<javax.xml.bind|Validator.setProperty(java.lang.String,java.lang.Object) 20c199f6> Attempting to set an undefined property will result in a PropertyException being thrown. 
<javax.xml.bind|Validator.setProperty(java.lang.String,java.lang.Object) 25e3b185> See Supported Properties. 
<javax.xml.bind|Validator.setProperty(java.lang.String,java.lang.Object) 83af0b54> @throws:PropertyException when there is an error processing the given property or value. 
<javax.xml.bind|Validator.setProperty(java.lang.String,java.lang.Object) fd0d9b0b> @throws:IllegalArgumentException If the name parameter is null. 
<javax.xml.bind|Validator.getProperty(java.lang.String) df85056b> Get the particular property in the underlying implementation of Validator. 
<javax.xml.bind|Validator.getProperty(java.lang.String) 10a5f4aa> This method can only be used to get one of the standard JAXB defined properties above or a provider specific property. 
<javax.xml.bind|Validator.getProperty(java.lang.String) 893f95ea> Attempting to get an undefined property will result in a PropertyException being thrown. 
<javax.xml.bind|Validator.getProperty(java.lang.String) 25e3b185> See Supported Properties. 
<javax.xml.bind|Validator.getProperty(java.lang.String) d7ee175b> @return:the value of the requested property. 
<javax.xml.bind|Validator.getProperty(java.lang.String) 33b30015> @throws:PropertyException when there is an error retrieving the given property or value property name. 
<javax.xml.bind|Validator.getProperty(java.lang.String) fd0d9b0b> @throws:IllegalArgumentException If the name parameter is null. 
<javax.xml.bind|ValidationException 16999180> This exception indicates that an error has occurred while performing a validate operation. 
<javax.xml.bind|ValidationException 90efcd06> The ValidationEventHandler can cause this exception to be thrown during the validate operations. 
<javax.xml.bind|ValidationException 67b832fb> See {@link ValidationEventHandler#handleEvent(ValidationEvent) ValidationEventHandler.handleEvent(ValidationEvent)}. 
<javax.xml.bind|ValidationException.ValidationException(java.lang.String) 829899a3> Construct an ValidationException with the specified detail message. 
<javax.xml.bind|ValidationException.ValidationException(java.lang.String) 9737b3ac> The errorCode and linkedException will default to null. 
<javax.xml.bind|ValidationException.ValidationException(java.lang.String,java.lang.String) acbfd7af> Construct an ValidationException with the specified detail message and vendor specific errorCode. 
<javax.xml.bind|ValidationException.ValidationException(java.lang.String,java.lang.String) bd427e8b> The linkedException will default to null. 
<javax.xml.bind|ValidationException.ValidationException(java.lang.Throwable) 18a42c47> Construct an ValidationException with a linkedException. 
<javax.xml.bind|ValidationException.ValidationException(java.lang.Throwable) 78efbd0d> The detail message and vendor specific errorCode will default to null. 
<javax.xml.bind|ValidationException.ValidationException(java.lang.String,java.lang.Throwable) e498482b> Construct an ValidationException with the specified detail message and linkedException. 
<javax.xml.bind|ValidationException.ValidationException(java.lang.String,java.lang.Throwable) 5959e1bc> The errorCode will default to null. 
<javax.xml.bind|ValidationException.ValidationException(java.lang.String,java.lang.String,java.lang.Throwable) fc465ad5> Construct an ValidationException with the specified detail message, vendor specific errorCode, and linkedException. 
<javax.xml.bind|ValidationEventLocator fc3f3fb5> Encapsulate the location of a ValidationEvent. 
<javax.xml.bind|ValidationEventLocator 3e2f362a> The ValidationEventLocator indicates where the ValidationEvent occurred. 
<javax.xml.bind|ValidationEventLocator 1e82296d> Different fields will be set depending on the type of validation that was being performed when the error or warning was detected. 
<javax.xml.bind|ValidationEventLocator c38d4e00> For example, on-demand validation would produce locators that contained references to objects in the Java content tree while unmarshal-time validation would produce locators containing information appropriate to the source of the XML data (file, url, Node, etc). 
<javax.xml.bind|ValidationEventLocator.getURL() 4676724f> Return the name of the XML source as a URL if available. 
<javax.xml.bind|ValidationEventLocator.getURL() 7b16287b> @return:the name of the XML source as a URL or null if unavailable. 
<javax.xml.bind|ValidationEventLocator.getOffset() 6c7651fa> Return the byte offset if available. 
<javax.xml.bind|ValidationEventLocator.getOffset() ac4fb846> @return:the byte offset into the input source or -1 if unavailable. 
<javax.xml.bind|ValidationEventLocator.getLineNumber() 271b1483> Return the line number if available. 
<javax.xml.bind|ValidationEventLocator.getLineNumber() e2c5a3b> @return:the line number or -1 if unavailable. 
<javax.xml.bind|ValidationEventLocator.getColumnNumber() cb25d3bb> Return the column number if available. 
<javax.xml.bind|ValidationEventLocator.getColumnNumber() 82c9cd73> @return:the column number or -1 if unavailable. 
<javax.xml.bind|ValidationEventLocator.getObject() f2b2cebb> Return a reference to the object in the Java content tree if available. 
<javax.xml.bind|ValidationEventLocator.getObject() d08a6f8f> @return:a reference to the object in the Java content tree or null if unavailable. 
<javax.xml.bind|ValidationEventLocator.getNode() 7a69f394> Return a reference to the DOM Node if available. 
<javax.xml.bind|ValidationEventLocator.getNode() 77fbca56> @return:a reference to the DOM Node or null if unavailable. 
<javax.xml.bind|ValidationEventHandler afaa8aee> A basic event handler interface for validation errors. 
<javax.xml.bind|ValidationEventHandler 641a4023> If an application needs to implement customized event handling, it must implement this interface and then register it with either the {@link Unmarshaller#setEventHandler(ValidationEventHandler) Unmarshaller}, the {@link Validator#setEventHandler(ValidationEventHandler) Validator}, or the {@link Marshaller#setEventHandler(ValidationEventHandler) Marshaller}. 
<javax.xml.bind|ValidationEventHandler 9eb79f6a> The JAXB Provider will then report validation errors and warnings encountered during the unmarshal, marshal, and validate operations to these event handlers. 
<javax.xml.bind|ValidationEventHandler e2fda407> If the handleEvent method throws an unchecked runtime exception, the JAXB Provider must treat that as if the method returned false, effectively terminating whatever operation was in progress at the time (unmarshal, validate, or marshal). 
<javax.xml.bind|ValidationEventHandler 1f8f681> Modifying the Java content tree within your event handler is undefined by the specification and may result in unexpected behaviour. 
<javax.xml.bind|ValidationEventHandler 6af10bc9> Failing to return false from the handleEvent method after encountering a fatal error is undefined by the specification and may result in unexpected behavior. 
<javax.xml.bind|ValidationEventHandler 8f97ae1d> Default Event Handler See: Validator javadocs . 
<javax.xml.bind|ValidationEventHandler.handleEvent(javax.xml.bind.ValidationEvent) 5ea13448> Receive notification of a validation warning or error. 
<javax.xml.bind|ValidationEventHandler.handleEvent(javax.xml.bind.ValidationEvent) 737d69d0> The ValidationEvent will have a {@link ValidationEventLocator ValidationEventLocator} embedded in it that indicates where the error or warning occurred. 
<javax.xml.bind|ValidationEventHandler.handleEvent(javax.xml.bind.ValidationEvent) 2e381df3> If an unchecked runtime exception is thrown from this method, the JAXB provider will treat it as if the method returned false and interrupt the current unmarshal, validate, or marshal operation. 
<javax.xml.bind|ValidationEventHandler.handleEvent(javax.xml.bind.ValidationEvent) 1f3b90cf> @return:true if the JAXB Provider should attempt to continue the current unmarshal, validate, or marshal operation after handling this warning/error, false if the provider should terminate the current operation with the appropriate UnmarshalException, ValidationException, or MarshalException. 
<javax.xml.bind|ValidationEventHandler.handleEvent(javax.xml.bind.ValidationEvent) afe2aaf6> @throws:IllegalArgumentException if the event object is null. 
<javax.xml.bind|ValidationEvent e2ed9c4> This event indicates that a problem was encountered while validating the incoming XML data during an unmarshal operation, while performing on-demand validation of the Java content tree, or while marshalling the Java content tree back to XML data. 
<javax.xml.bind|ValidationEvent.getSeverity() c7e31fd7> Retrieve the severity code for this warning/error. 
<javax.xml.bind|ValidationEvent.getSeverity() 7fbe7fe7> Must be one of ValidationError.WARNING, ValidationError.ERROR, or ValidationError.FATAL_ERROR. 
<javax.xml.bind|ValidationEvent.getSeverity() 1c18809f> @return:the severity code for this warning/error. 
<javax.xml.bind|ValidationEvent.getMessage() 21cc3f6c> Retrieve the text message for this warning/error. 
<javax.xml.bind|ValidationEvent.getMessage() c6a84d3b> @return:the text message for this warning/error or null if one wasn't set. 
<javax.xml.bind|ValidationEvent.getLinkedException() 232fda26> Retrieve the linked exception for this warning/error. 
<javax.xml.bind|ValidationEvent.getLinkedException() 91dd8ef5> @return:the linked exception for this warning/error or null if one wasn't set. 
<javax.xml.bind|ValidationEvent.getLocator() fe678cab> Retrieve the locator for this warning/error. 
<javax.xml.bind|ValidationEvent.getLocator() 91f77857> @return:the locator that indicates where the warning/error occurred. 
<javax.xml.bind|ValidationEvent.WARNING 5c5c2f67> Conditions that are not errors or fatal errors as defined by the XML 1.0 recommendation. 
<javax.xml.bind|ValidationEvent.ERROR d48b3171> Conditions that correspond to the definition of "error" in section 1.2 of the W3C XML 1.0 Recommendation. 
<javax.xml.bind|ValidationEvent.FATAL_ERROR 9ece7bf7> Conditions that correspond to the definition of "fatal error" in section 1.2 of the W3C XML 1.0 Recommendation. 
<javax.xml.bind|UnmarshallerHandler a74533d> Unmarshaller implemented as SAX ContentHandler. 
<javax.xml.bind|UnmarshallerHandler c1cfa855> Applications can use this interface to use their JAXB provider as a component in an XML pipeline. 
<javax.xml.bind|UnmarshallerHandler 5dabbc2a> For example: JAXBContext context = JAXBContext.newInstance( "org.acme.foo" ); Unmarshaller unmarshaller = context.createUnmarshaller(); UnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler(); SAXParserFactory spf = SAXParserFactory.newInstance(); spf.setNamespaceAware( true ); XMLReader xmlReader = spf.newSAXParser().getXMLReader(); xmlReader.setContentHandler( unmarshallerHandler ); xmlReader.parse(new InputSource( new FileInputStream( XML_FILE ) ) ); MyObject myObject= (MyObject)unmarshallerHandler.getResult(); This interface is reusable: even if the user fails to unmarshal an object, s/he can still start a new round of unmarshalling. 
<javax.xml.bind|UnmarshallerHandler.getResult() ae8dfd10> Obtains the unmarshalled result. 
<javax.xml.bind|UnmarshallerHandler.getResult() e1a6905f> This method can be called only after this handler receives the endDocument SAX event. 
<javax.xml.bind|UnmarshallerHandler.getResult() 7b1f98eb> @exception:IllegalStateException if this method is called before this handler receives the endDocument event. 
<javax.xml.bind|UnmarshallerHandler.getResult() ba604d6d> @exception:JAXBException if there is any unmarshalling error. 
<javax.xml.bind|UnmarshallerHandler.getResult() 59eb7f66> Note that the implementation is allowed to throw SAXException during the parsing when it finds an error. 
<javax.xml.bind|UnmarshallerHandler.getResult() f41c7373> @return:always return a non-null valid object which was unmarshalled. 
<javax.xml.bind|Unmarshaller 555609ed> The Unmarshaller class governs the process of deserializing XML data into newly created Java content trees, optionally validating the XML data as it is unmarshalled. 
<javax.xml.bind|Unmarshaller 91f6df96> It provides an overloading of unmarshal methods for many different input kinds. 
<javax.xml.bind|Unmarshaller a1eefce0> Unmarshalling from a File: JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" ); Unmarshaller u = jc.createUnmarshaller(); Object o = u.unmarshal( new File( "nosferatu.xml" ) ); Unmarshalling from an InputStream: InputStream is = new FileInputStream( "nosferatu.xml" ); JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" ); Unmarshaller u = jc.createUnmarshaller(); Object o = u.unmarshal( is ); Unmarshalling from a URL: JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" ); Unmarshaller u = jc.createUnmarshaller(); URL url = new URL( "http://beaker.east/nosferatu.xml" ); Object o = u.unmarshal( url ); Unmarshalling from a StringBuffer using a javax.xml.transform.stream.StreamSource: JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" ); Unmarshaller u = jc.createUnmarshaller(); StringBuffer xmlStr = new StringBuffer( "&lt;?xml version=&quot;1.0&quot;?&gt;..." ); Object o = u.unmarshal( new StreamSource( new StringReader( xmlStr.toString() ) ) ); Unmarshalling from a org.w3c.dom.Node: JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" ); Unmarshaller u = jc.createUnmarshaller(); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setNamespaceAware(true); DocumentBuilder db = dbf.newDocumentBuilder(); Document doc = db.parse(new File( "nosferatu.xml")); Object o = u.unmarshal( doc ); Unmarshalling from a javax.xml.transform.sax.SAXSource using a client specified validating SAX2.0 parser: // configure a validating SAX2.0 parser (Xerces2) static final String JAXP_SCHEMA_LANGUAGE = "http://java.sun.com/xml/jaxp/properties/schemaLanguage"; static final String JAXP_SCHEMA_LOCATION = "http://java.sun.com/xml/jaxp/properties/schemaSource"; static final String W3C_XML_SCHEMA = "http://www.w3.org/2001/XMLSchema"; System.setProperty( "javax.xml.parsers.SAXParserFactory", "org.apache.xerces.jaxp.SAXParserFactoryImpl" ); SAXParserFactory spf = SAXParserFactory.newInstance(); spf.setNamespaceAware(true); spf.setValidating(true); SAXParser saxParser = spf.newSAXParser(); try { saxParser.setProperty(JAXP_SCHEMA_LANGUAGE, W3C_XML_SCHEMA); saxParser.setProperty(JAXP_SCHEMA_LOCATION, "http://...."); } catch (SAXNotRecognizedException x) { // exception handling omitted } XMLReader xmlReader = saxParser.getXMLReader(); SAXSource source = new SAXSource( xmlReader, new InputSource( "http://..." ) ); // Setup JAXB to unmarshal JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" ); Unmarshaller u = jc.createUnmarshaller(); ValidationEventCollector vec = new ValidationEventCollector(); u.setEventHandler( vec ); // turn off the JAXB provider's default validation mechanism to // avoid duplicate validation u.setValidating( false ) // unmarshal Object o = u.unmarshal( source ); // check for events if( vec.hasEvents() ) { // iterate over events } Unmarshalling from a StAX XMLStreamReader: JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" ); Unmarshaller u = jc.createUnmarshaller(); javax.xml.stream.XMLStreamReader xmlStreamReader = javax.xml.stream.XMLInputFactory().newInstance().createXMLStreamReader( ... ); Object o = u.unmarshal( xmlStreamReader ); Unmarshalling from a StAX XMLEventReader: JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" ); Unmarshaller u = jc.createUnmarshaller(); javax.xml.stream.XMLEventReader xmlEventReader = javax.xml.stream.XMLInputFactory().newInstance().createXMLEventReader( ... ); Object o = u.unmarshal( xmlEventReader ); Unmarshalling XML Data Unmarshalling can deserialize XML data that represents either an entire XML document or a subtree of an XML document. 
<javax.xml.bind|Unmarshaller c870becc> Typically, it is sufficient to use the unmarshalling methods described by Unmarshal root element that is declared globally. 
<javax.xml.bind|Unmarshaller 1687b59d> These unmarshal methods utilize {@link JAXBContext}'s mapping of global XML element declarations and type definitions to JAXB mapped classes to initiate the unmarshalling of the root element of XML data. 
<javax.xml.bind|Unmarshaller a90a2374> When the {@link JAXBContext}'s mappings are not sufficient to unmarshal the root element of XML data, the application can assist the unmarshalling process by using the unmarshal by declaredType methods. 
<javax.xml.bind|Unmarshaller e289625f> These methods are useful for unmarshalling XML data where the root element corresponds to a local element declaration in the schema. 
<javax.xml.bind|Unmarshaller c894698e> An unmarshal method never returns null. 
<javax.xml.bind|Unmarshaller 7010793d> If the unmarshal process is unable to unmarshal the root of XML content to a JAXB mapped object, a fatal error is reported that terminates processing by throwing JAXBException. 
<javax.xml.bind|Unmarshaller aec1fc09> Unmarshal a root element that is globally declared The unmarshal methods that do not have an declaredType parameter use {@link JAXBContext} to unmarshal the root element of an XML data. 
<javax.xml.bind|Unmarshaller 16d7813a> The {@link JAXBContext} instance is the one that was used to create this Unmarshaller. 
<javax.xml.bind|Unmarshaller 5ad26cdb> The {@link JAXBContext} instance maintains a mapping of globally declared XML element and type definition names to JAXB mapped classes. 
<javax.xml.bind|Unmarshaller ffc4dc72> The unmarshal method checks if {@link JAXBContext} has a mapping from the root element's XML name and/or @xsi:type to a JAXB mapped class. 
<javax.xml.bind|Unmarshaller ca5568e5> If it does, it umarshalls the XML data using the appropriate JAXB mapped class. 
<javax.xml.bind|Unmarshaller 52dd4de5> Note that when the root element name is unknown and the root element has an @xsi:type, the XML data is unmarshalled using that JAXB mapped class as the value of a {@link JAXBElement}. 
<javax.xml.bind|Unmarshaller b98d6d87> When the {@link JAXBContext} object does not have a mapping for the root element's name nor its @xsi:type, if it exists, then the unmarshal operation will abort immediately by throwing a {@link UnmarshalException UnmarshalException}. 
<javax.xml.bind|Unmarshaller b6be6bb2> This exception scenario can be worked around by using the unmarshal by declaredType methods described in the next subsection. 
<javax.xml.bind|Unmarshaller 8351ad1> Unmarshal by Declared Type The unmarshal methods with a declaredType parameter enable an application to deserialize a root element of XML data, even when there is no mapping in {@link JAXBContext} of the root element's XML name. 
<javax.xml.bind|Unmarshaller df10e7a5> The unmarshaller unmarshals the root element using the application provided mapping specified as the declaredType parameter. 
<javax.xml.bind|Unmarshaller 98474f9d> Note that even when the root element's element name is mapped by {@link JAXBContext}, the declaredType parameter overrides that mapping for deserializing the root element when using these unmarshal methods. 
<javax.xml.bind|Unmarshaller 1b3a2dd3> Additionally, when the root element of XML data has an xsi:type attribute and that attribute's value references a type definition that is mapped to a JAXB mapped class by {@link JAXBContext}, that the root element's xsi:type attribute takes precedence over the unmarshal methods declaredType parameter. 
<javax.xml.bind|Unmarshaller 20fc9699> These methods always return a JAXBElement&lt;declaredType> instance. 
<javax.xml.bind|Unmarshaller 27b4cf44> The table below shows how the properties of the returned JAXBElement instance are set. 
<javax.xml.bind|Unmarshaller 89e5f7eb> Unmarshal By Declared Type returned JAXBElement JAXBElement Property Value name xml element name value instanceof declaredType declaredType unmarshal method declaredType parameter scope null (actual scope is unknown) The following is an example of unmarshal by declaredType method. 
<javax.xml.bind|Unmarshaller 7248a839> Unmarshal by declaredType from a org.w3c.dom.Node: Schema fragment for example &lt;xs:schema> &lt;xs:complexType name="FooType">...&lt;\xs:complexType> &lt;!-- global element declaration "PurchaseOrder" --> &lt;xs:element name="PurchaseOrder"> &lt;xs:complexType> &lt;xs:sequence> &lt;!-- local element declaration "foo" --> &lt;xs:element name="foo" type="FooType"/> ... &lt;/xs:sequence> &lt;/xs:complexType> &lt;/xs:element> &lt;/xs:schema> JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" ); Unmarshaller u = jc.createUnmarshaller(); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setNamespaceAware(true); DocumentBuilder db = dbf.newDocumentBuilder(); Document doc = db.parse(new File( "nosferatu.xml")); Element fooSubtree = ...; // traverse DOM till reach xml element foo, constrained by a // local element declaration in schema. 
<javax.xml.bind|Unmarshaller 429dd2c> // FooType is the JAXB mapping of the type of local element declaration foo. 
<javax.xml.bind|Unmarshaller a82a8b23> JAXBElement&lt;FooType> foo = u.unmarshal( fooSubtree, FooType.class); Support for SAX2.0 Compliant Parsers A client application has the ability to select the SAX2.0 compliant parser of their choice. 
<javax.xml.bind|Unmarshaller 25aeeb8b> If a SAX parser is not selected, then the JAXB Provider's default parser will be used. 
<javax.xml.bind|Unmarshaller e9d65017> Even though the JAXB Provider's default parser is not required to be SAX2.0 compliant, all providers are required to allow a client application to specify their own SAX2.0 parser. 
<javax.xml.bind|Unmarshaller 12e857fb> Some providers may require the client application to specify the SAX2.0 parser at schema compile time. 
<javax.xml.bind|Unmarshaller 7983da91> See {@link #unmarshal(javax.xml.transform.Source) unmarshal(Source)} for more detail. 
<javax.xml.bind|Unmarshaller 1248a522> Validation and Well-Formedness A client application can enable or disable JAXP 1.3 validation mechanism via the setSchema(javax.xml.validation.Schema) API. 
<javax.xml.bind|Unmarshaller 33d760a7> Sophisticated clients can specify their own validating SAX 2.0 compliant parser and bypass the JAXP 1.3 validation mechanism using the {@link #unmarshal(javax.xml.transform.Source) unmarshal(Source)} API. 
<javax.xml.bind|Unmarshaller 608c6c55> Since unmarshalling invalid XML content is defined in JAXB 2.0, the Unmarshaller default validation event handler was made more lenient than in JAXB 1.0. 
<javax.xml.bind|Unmarshaller 799ad000> When schema-derived code generated by JAXB 1.0 binding compiler is registered with {@link JAXBContext}, the default unmarshal validation handler is {@link javax.xml.bind.helpers.DefaultValidationEventHandler} and it terminates the marshal operation after encountering either a fatal error or an error. 
<javax.xml.bind|Unmarshaller 673904d3> For a JAXB 2.0 client application, there is no explicitly defined default validation handler and the default event handling only terminates the marshal operation after encountering a fatal error. 
<javax.xml.bind|Unmarshaller 49d5f2d4> Supported Properties There currently are not any properties required to be supported by all JAXB Providers on Unmarshaller. 
<javax.xml.bind|Unmarshaller 10551f47> However, some providers may support their own set of provider specific properties. 
<javax.xml.bind|Unmarshaller 43f44271> Unmarshal Event Callbacks The {@link Unmarshaller} provides two styles of callback mechanisms that allow application specific processing during key points in the unmarshalling process. 
<javax.xml.bind|Unmarshaller abe1bf33> In 'class defined' event callbacks, application specific code placed in JAXB mapped classes is triggered during unmarshalling. 
<javax.xml.bind|Unmarshaller 2148ffa7> 'External listeners' allow for centralized processing of unmarshal events in one callback method rather than by type event callbacks. 
<javax.xml.bind|Unmarshaller 6e9cb190> 'Class defined' event callback methods allow any JAXB mapped class to specify its own specific callback methods by defining methods with the following method signature: // This method is called immediately after the object is created and before the unmarshalling of this // object begins. 
<javax.xml.bind|Unmarshaller a166b9c5> The callback provides an opportunity to initialize JavaBean properties prior to unmarshalling. 
<javax.xml.bind|Unmarshaller ad0551e8> void beforeUnmarshal(Unmarshaller, Object parent); //This method is called after all the properties (except IDREF) are unmarshalled for this object, //but before this object is set to the parent object. 
<javax.xml.bind|Unmarshaller 79b599e0> void afterUnmarshal(Unmarshaller, Object parent); The class defined callback methods should be used when the callback method requires access to non-public methods and/or fields of the class. 
<javax.xml.bind|Unmarshaller 3e523914> The external listener callback mechanism enables the registration of a {@link Listener} instance with an {@link Unmarshaller#setListener(Listener)}. 
<javax.xml.bind|Unmarshaller 969b22bd> The external listener receives all callback events, allowing for more centralized processing than per class defined callback methods. 
<javax.xml.bind|Unmarshaller 4ffa1131> The external listener receives events when unmarshalling proces is marshalling to a JAXB element or to JAXB mapped class. 
<javax.xml.bind|Unmarshaller b22430e8> The 'class defined' and external listener event callback methods are independent of each other, both can be called for one event. 
<javax.xml.bind|Unmarshaller c9de0927> The invocation ordering when both listener callback methods exist is defined in {@link Listener#beforeUnmarshal(Object, Object)} and {@link Listener#afterUnmarshal(Object, Object)}. 
<javax.xml.bind|Unmarshaller 172528a1> An event callback method throwing an exception terminates the current unmarshal process. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.File) dca65aeb> Unmarshal XML data from the specified file and return the resulting content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.File) 9dec31c5> Implements Unmarshal Global Root Element. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.File) ebe402e9> @return:the newly created root object of the java content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.File) 48139f3e> @throws:JAXBException If any unexpected errors occur while unmarshalling. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.File) 1be8168f> @throws:UnmarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Unmarshaller is unable to perform the XML to Java binding. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.File) 57b19b59> See Unmarshalling XML Data. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.File) 619e93e4> @throws:IllegalArgumentException If the file parameter is null. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.InputStream) 3ef255c7> Unmarshal XML data from the specified InputStream and return the resulting content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.InputStream) 3d243787> Validation event location information may be incomplete when using this form of the unmarshal API. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.InputStream) 9dec31c5> Implements Unmarshal Global Root Element. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.InputStream) ebe402e9> @return:the newly created root object of the java content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.InputStream) 48139f3e> @throws:JAXBException If any unexpected errors occur while unmarshalling. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.InputStream) 1be8168f> @throws:UnmarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Unmarshaller is unable to perform the XML to Java binding. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.InputStream) 57b19b59> See Unmarshalling XML Data. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.InputStream) aaf0b950> @throws:IllegalArgumentException If the InputStream parameter is null. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.Reader) 260b93d5> Unmarshal XML data from the specified Reader and return the resulting content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.Reader) aece790c> Validation event location information may be incomplete when using this form of the unmarshal API, because a Reader does not provide the system ID. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.Reader) 9dec31c5> Implements Unmarshal Global Root Element. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.Reader) ebe402e9> @return:the newly created root object of the java content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.Reader) 48139f3e> @throws:JAXBException If any unexpected errors occur while unmarshalling. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.Reader) 1be8168f> @throws:UnmarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Unmarshaller is unable to perform the XML to Java binding. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.Reader) 57b19b59> See Unmarshalling XML Data. 
<javax.xml.bind|Unmarshaller.unmarshal(java.io.Reader) aaf0b950> @throws:IllegalArgumentException If the InputStream parameter is null. 
<javax.xml.bind|Unmarshaller.unmarshal(java.net.URL) 56f989f7> Unmarshal XML data from the specified URL and return the resulting content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(java.net.URL) 9dec31c5> Implements Unmarshal Global Root Element. 
<javax.xml.bind|Unmarshaller.unmarshal(java.net.URL) ebe402e9> @return:the newly created root object of the java content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(java.net.URL) 48139f3e> @throws:JAXBException If any unexpected errors occur while unmarshalling. 
<javax.xml.bind|Unmarshaller.unmarshal(java.net.URL) 1be8168f> @throws:UnmarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Unmarshaller is unable to perform the XML to Java binding. 
<javax.xml.bind|Unmarshaller.unmarshal(java.net.URL) 57b19b59> See Unmarshalling XML Data. 
<javax.xml.bind|Unmarshaller.unmarshal(java.net.URL) 5c56f4f0> @throws:IllegalArgumentException If the URL parameter is null. 
<javax.xml.bind|Unmarshaller.unmarshal(org.xml.sax.InputSource) 1381fd7a> Unmarshal XML data from the specified SAX InputSource and return the resulting content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(org.xml.sax.InputSource) 9dec31c5> Implements Unmarshal Global Root Element. 
<javax.xml.bind|Unmarshaller.unmarshal(org.xml.sax.InputSource) ebe402e9> @return:the newly created root object of the java content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(org.xml.sax.InputSource) 48139f3e> @throws:JAXBException If any unexpected errors occur while unmarshalling. 
<javax.xml.bind|Unmarshaller.unmarshal(org.xml.sax.InputSource) 1be8168f> @throws:UnmarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Unmarshaller is unable to perform the XML to Java binding. 
<javax.xml.bind|Unmarshaller.unmarshal(org.xml.sax.InputSource) 57b19b59> See Unmarshalling XML Data. 
<javax.xml.bind|Unmarshaller.unmarshal(org.xml.sax.InputSource) 97323178> @throws:IllegalArgumentException If the InputSource parameter is null. 
<javax.xml.bind|Unmarshaller.unmarshal(org.w3c.dom.Node) 226be8f9> Unmarshal global XML data from the specified DOM tree and return the resulting content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(org.w3c.dom.Node) 9dec31c5> Implements Unmarshal Global Root Element. 
<javax.xml.bind|Unmarshaller.unmarshal(org.w3c.dom.Node) ebe402e9> @return:the newly created root object of the java content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(org.w3c.dom.Node) 48139f3e> @throws:JAXBException If any unexpected errors occur while unmarshalling. 
<javax.xml.bind|Unmarshaller.unmarshal(org.w3c.dom.Node) 1be8168f> @throws:UnmarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Unmarshaller is unable to perform the XML to Java binding. 
<javax.xml.bind|Unmarshaller.unmarshal(org.w3c.dom.Node) 57b19b59> See Unmarshalling XML Data. 
<javax.xml.bind|Unmarshaller.unmarshal(org.w3c.dom.Node) 6678a0f4> @throws:IllegalArgumentException If the Node parameter is null. 
<javax.xml.bind|Unmarshaller.unmarshal(org.w3c.dom.Node,java.lang.Class) c8b57846> Unmarshal XML data by JAXB mapped declaredType and return the resulting content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(org.w3c.dom.Node,java.lang.Class) 49441990> Implements Unmarshal by Declared Type. 
<javax.xml.bind|Unmarshaller.unmarshal(org.w3c.dom.Node,java.lang.Class) af43a800> @return:JAXB Element representation of node. 
<javax.xml.bind|Unmarshaller.unmarshal(org.w3c.dom.Node,java.lang.Class) 48139f3e> @throws:JAXBException If any unexpected errors occur while unmarshalling. 
<javax.xml.bind|Unmarshaller.unmarshal(org.w3c.dom.Node,java.lang.Class) 1be8168f> @throws:UnmarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Unmarshaller is unable to perform the XML to Java binding. 
<javax.xml.bind|Unmarshaller.unmarshal(org.w3c.dom.Node,java.lang.Class) 57b19b59> See Unmarshalling XML Data. 
<javax.xml.bind|Unmarshaller.unmarshal(org.w3c.dom.Node,java.lang.Class) 4e0975f3> @throws:IllegalArgumentException If any parameter is null. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source) 4ccbdca4> Unmarshal XML data from the specified XML Source and return the resulting content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source) 9dec31c5> Implements Unmarshal Global Root Element. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source) e0fa883e> SAX 2.0 Parser Pluggability A client application can choose not to use the default parser mechanism supplied with their JAXB provider. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source) 55a1110d> Any SAX 2.0 compliant parser can be substituted for the JAXB provider's default mechanism. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source) 66358611> To do so, the client application must properly configure a SAXSource containing an XMLReader implemented by the SAX 2.0 parser provider. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source) 2827e943> If the XMLReader has an org.xml.sax.ErrorHandler registered on it, it will be replaced by the JAXB Provider so that validation errors can be reported via the ValidationEventHandler mechanism of JAXB. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source) a23eb92c> If the SAXSource does not contain an XMLReader, then the JAXB provider's default parser mechanism will be used. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source) 5fed381a> This parser replacement mechanism can also be used to replace the JAXB provider's unmarshal-time validation engine. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source) d6715ce3> The client application must properly configure their SAX 2.0 compliant parser to perform validation (as shown in the example above). 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source) db198d50> Any SAXParserExceptions encountered by the parser during the unmarshal operation will be processed by the JAXB provider and converted into JAXB ValidationEvent objects which will be reported back to the client via the ValidationEventHandler registered with the Unmarshaller. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source) 9cbc073d> Note: specifying a substitute validating SAX 2.0 parser for unmarshalling does not necessarily replace the validation engine used by the JAXB provider for performing on-demand validation. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source) 8fc00576> The only way for a client application to specify an alternate parser mechanism to be used during unmarshal is via the unmarshal(SAXSource) API. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source) 9a390dfa> All other forms of the unmarshal method (File, URL, Node, etc) will use the JAXB provider's default parser and validator mechanisms. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source) ebe402e9> @return:the newly created root object of the java content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source) 48139f3e> @throws:JAXBException If any unexpected errors occur while unmarshalling. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source) 1be8168f> @throws:UnmarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Unmarshaller is unable to perform the XML to Java binding. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source) 57b19b59> See Unmarshalling XML Data. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source) bbca0b7a> @throws:IllegalArgumentException If the Source parameter is null. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source,java.lang.Class) c1f33681> Unmarshal XML data from the specified XML Source by declaredType and return the resulting content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source,java.lang.Class) 263aa6d2> Implements Unmarshal by Declared Type See SAX 2.0 Parser Pluggability. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source,java.lang.Class) c3b9ef27> @return:Java content rooted by JAXB Element. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source,java.lang.Class) 48139f3e> @throws:JAXBException If any unexpected errors occur while unmarshalling. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source,java.lang.Class) 1be8168f> @throws:UnmarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Unmarshaller is unable to perform the XML to Java binding. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source,java.lang.Class) 57b19b59> See Unmarshalling XML Data. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.transform.Source,java.lang.Class) 4e0975f3> @throws:IllegalArgumentException If any parameter is null. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader) 92bfc224> Unmarshal XML data from the specified pull parser and return the resulting content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader) 9dec31c5> Implements Unmarshal Global Root Element. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader) f6f654ab> This method assumes that the parser is on a START_DOCUMENT or START_ELEMENT event. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader) 84c8797a> Unmarshalling will be done from this start event to the corresponding end event. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader) 99d5c503> If this method returns successfully, the reader will be pointing at the token right after the end event. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader) ebe402e9> @return:the newly created root object of the java content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader) 48139f3e> @throws:JAXBException If any unexpected errors occur while unmarshalling. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader) 1be8168f> @throws:UnmarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Unmarshaller is unable to perform the XML to Java binding. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader) 57b19b59> See Unmarshalling XML Data. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader) dfe4405e> @throws:IllegalArgumentException If the reader parameter is null. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader) 1a13d9fa> @throws:IllegalStateException If reader is not pointing to a START_DOCUMENT or START_ELEMENT event. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader,java.lang.Class) 6c80e193> Unmarshal root element to JAXB mapped declaredType and return the resulting content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader,java.lang.Class) f015e56e> This method implements unmarshal by declaredType. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader,java.lang.Class) f6f654ab> This method assumes that the parser is on a START_DOCUMENT or START_ELEMENT event. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader,java.lang.Class) 84c8797a> Unmarshalling will be done from this start event to the corresponding end event. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader,java.lang.Class) 99d5c503> If this method returns successfully, the reader will be pointing at the token right after the end event. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader,java.lang.Class) d9fc0bf0> @return:content tree rooted by JAXB Element representation. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader,java.lang.Class) 48139f3e> @throws:JAXBException If any unexpected errors occur while unmarshalling. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader,java.lang.Class) 1be8168f> @throws:UnmarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Unmarshaller is unable to perform the XML to Java binding. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader,java.lang.Class) 57b19b59> See Unmarshalling XML Data. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLStreamReader,java.lang.Class) 4e0975f3> @throws:IllegalArgumentException If any parameter is null. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader) 92bfc224> Unmarshal XML data from the specified pull parser and return the resulting content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader) 8c1d88d5> This method is an Unmarshal Global Root method. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader) f6f654ab> This method assumes that the parser is on a START_DOCUMENT or START_ELEMENT event. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader) 84c8797a> Unmarshalling will be done from this start event to the corresponding end event. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader) 99d5c503> If this method returns successfully, the reader will be pointing at the token right after the end event. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader) ebe402e9> @return:the newly created root object of the java content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader) 48139f3e> @throws:JAXBException If any unexpected errors occur while unmarshalling. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader) 1be8168f> @throws:UnmarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Unmarshaller is unable to perform the XML to Java binding. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader) 57b19b59> See Unmarshalling XML Data. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader) dfe4405e> @throws:IllegalArgumentException If the reader parameter is null. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader) 1a13d9fa> @throws:IllegalStateException If reader is not pointing to a START_DOCUMENT or START_ELEMENT event. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader,java.lang.Class) 6c80e193> Unmarshal root element to JAXB mapped declaredType and return the resulting content tree. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader,java.lang.Class) f015e56e> This method implements unmarshal by declaredType. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader,java.lang.Class) f6f654ab> This method assumes that the parser is on a START_DOCUMENT or START_ELEMENT event. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader,java.lang.Class) 84c8797a> Unmarshalling will be done from this start event to the corresponding end event. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader,java.lang.Class) 99d5c503> If this method returns successfully, the reader will be pointing at the token right after the end event. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader,java.lang.Class) d9fc0bf0> @return:content tree rooted by JAXB Element representation. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader,java.lang.Class) 48139f3e> @throws:JAXBException If any unexpected errors occur while unmarshalling. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader,java.lang.Class) 1be8168f> @throws:UnmarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Unmarshaller is unable to perform the XML to Java binding. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader,java.lang.Class) 57b19b59> See Unmarshalling XML Data. 
<javax.xml.bind|Unmarshaller.unmarshal(javax.xml.stream.XMLEventReader,java.lang.Class) 4e0975f3> @throws:IllegalArgumentException If any parameter is null. 
<javax.xml.bind|Unmarshaller.getUnmarshallerHandler() 968c4252> Get an unmarshaller handler object that can be used as a component in an XML pipeline. 
<javax.xml.bind|Unmarshaller.getUnmarshallerHandler() b31a697b> The JAXB Provider can return the same handler object for multiple invocations of this method. 
<javax.xml.bind|Unmarshaller.getUnmarshallerHandler() e2ab98b7> In other words, this method does not necessarily create a new instance of UnmarshallerHandler. 
<javax.xml.bind|Unmarshaller.getUnmarshallerHandler() d0693517> If the application needs to use more than one UnmarshallerHandler, it should create more than one Unmarshaller. 
<javax.xml.bind|Unmarshaller.getUnmarshallerHandler() 623b9761> @return:the unmarshaller handler object. 
<javax.xml.bind|Unmarshaller.setValidating(boolean) 91281817> Specifies whether or not the default validation mechanism of the Unmarshaller should validate during unmarshal operations. 
<javax.xml.bind|Unmarshaller.setValidating(boolean) e456683a> By default, the Unmarshaller does not validate. 
<javax.xml.bind|Unmarshaller.setValidating(boolean) a4f2698e> This method may only be invoked before or after calling one of the unmarshal methods. 
<javax.xml.bind|Unmarshaller.setValidating(boolean) e567efd3> This method only controls the JAXB Provider's default unmarshal-time validation mechanism - it has no impact on clients that specify their own validating SAX 2.0 compliant parser. 
<javax.xml.bind|Unmarshaller.setValidating(boolean) 82117860> Clients that specify their own unmarshal-time validation mechanism may wish to turn off the JAXB Provider's default validation mechanism via this API to avoid "double validation". 
<javax.xml.bind|Unmarshaller.setValidating(boolean) 2ce569b8> This method is deprecated as of JAXB 2.0 - please use the new {@link #setSchema(javax.xml.validation.Schema)} API. 
<javax.xml.bind|Unmarshaller.setValidating(boolean) e4a51e98> @throws:JAXBException if an error occurred while enabling or disabling validation at unmarshal time. 
<javax.xml.bind|Unmarshaller.setValidating(boolean) 138de74e> @throws:UnsupportedOperationException could be thrown if this method is invoked on an Unmarshaller created from a JAXBContext referencing JAXB 2.0 mapped classes. 
<javax.xml.bind|Unmarshaller.isValidating() 5601e20e> Indicates whether or not the Unmarshaller is configured to validate during unmarshal operations. 
<javax.xml.bind|Unmarshaller.isValidating() 72d03dec> This API returns the state of the JAXB Provider's default unmarshal-time validation mechanism. 
<javax.xml.bind|Unmarshaller.isValidating() 9397551a> This method is deprecated as of JAXB 2.0 - please use the new {@link #getSchema()} API. 
<javax.xml.bind|Unmarshaller.isValidating() ac69e108> @return:true if the Unmarshaller is configured to validate during unmarshal operations, false otherwise. 
<javax.xml.bind|Unmarshaller.isValidating() 9808b15a> @throws:JAXBException if an error occurs while retrieving the validating flag. 
<javax.xml.bind|Unmarshaller.isValidating() 138de74e> @throws:UnsupportedOperationException could be thrown if this method is invoked on an Unmarshaller created from a JAXBContext referencing JAXB 2.0 mapped classes. 
<javax.xml.bind|Unmarshaller.setEventHandler(javax.xml.bind.ValidationEventHandler) 126e3720> Allow an application to register a ValidationEventHandler. 
<javax.xml.bind|Unmarshaller.setEventHandler(javax.xml.bind.ValidationEventHandler) c8f47314> The ValidationEventHandler will be called by the JAXB Provider if any validation errors are encountered during calls to any of the unmarshal methods. 
<javax.xml.bind|Unmarshaller.setEventHandler(javax.xml.bind.ValidationEventHandler) 8fe8f9cb> If the client application does not register a ValidationEventHandler before invoking the unmarshal methods, then ValidationEvents will be handled by the default event handler which will terminate the unmarshal operation after the first error or fatal error is encountered. 
<javax.xml.bind|Unmarshaller.setEventHandler(javax.xml.bind.ValidationEventHandler) e12d3d25> Calling this method with a null parameter will cause the Unmarshaller to revert back to the default event handler. 
<javax.xml.bind|Unmarshaller.setEventHandler(javax.xml.bind.ValidationEventHandler) 778ea19b> @throws:JAXBException if an error was encountered while setting the event handler. 
<javax.xml.bind|Unmarshaller.getEventHandler() de7fd39f> Return the current event handler or the default event handler if one hasn't been set. 
<javax.xml.bind|Unmarshaller.getEventHandler() ef8f894b> @return:the current ValidationEventHandler or the default event handler if it hasn't been set. 
<javax.xml.bind|Unmarshaller.getEventHandler() 2fe6718a> @throws:JAXBException if an error was encountered while getting the current event handler. 
<javax.xml.bind|Unmarshaller.setProperty(java.lang.String,java.lang.Object) 5925c77> Set the particular property in the underlying implementation of Unmarshaller. 
<javax.xml.bind|Unmarshaller.setProperty(java.lang.String,java.lang.Object) 33bae51e> This method can only be used to set one of the standard JAXB defined properties above or a provider specific property. 
<javax.xml.bind|Unmarshaller.setProperty(java.lang.String,java.lang.Object) 20c199f6> Attempting to set an undefined property will result in a PropertyException being thrown. 
<javax.xml.bind|Unmarshaller.setProperty(java.lang.String,java.lang.Object) 25e3b185> See Supported Properties. 
<javax.xml.bind|Unmarshaller.setProperty(java.lang.String,java.lang.Object) 83af0b54> @throws:PropertyException when there is an error processing the given property or value. 
<javax.xml.bind|Unmarshaller.setProperty(java.lang.String,java.lang.Object) fd0d9b0b> @throws:IllegalArgumentException If the name parameter is null. 
<javax.xml.bind|Unmarshaller.getProperty(java.lang.String) 46812b6b> Get the particular property in the underlying implementation of Unmarshaller. 
<javax.xml.bind|Unmarshaller.getProperty(java.lang.String) 10a5f4aa> This method can only be used to get one of the standard JAXB defined properties above or a provider specific property. 
<javax.xml.bind|Unmarshaller.getProperty(java.lang.String) 893f95ea> Attempting to get an undefined property will result in a PropertyException being thrown. 
<javax.xml.bind|Unmarshaller.getProperty(java.lang.String) 25e3b185> See Supported Properties. 
<javax.xml.bind|Unmarshaller.getProperty(java.lang.String) d7ee175b> @return:the value of the requested property. 
<javax.xml.bind|Unmarshaller.getProperty(java.lang.String) 33b30015> @throws:PropertyException when there is an error retrieving the given property or value property name. 
<javax.xml.bind|Unmarshaller.getProperty(java.lang.String) fd0d9b0b> @throws:IllegalArgumentException If the name parameter is null. 
<javax.xml.bind|Unmarshaller.setSchema(javax.xml.validation.Schema) 1ab00750> Specify the JAXP 1.3 {@link javax.xml.validation.Schema Schema} object that should be used to validate subsequent unmarshal operations against. 
<javax.xml.bind|Unmarshaller.setSchema(javax.xml.validation.Schema) afcae6cf> Passing null into this method will disable validation. 
<javax.xml.bind|Unmarshaller.setSchema(javax.xml.validation.Schema) 79dcb84f> This method replaces the deprecated {@link #setValidating(boolean) setValidating(boolean)} API. 
<javax.xml.bind|Unmarshaller.setSchema(javax.xml.validation.Schema) e88703b9> Initially this property is set to null. 
<javax.xml.bind|Unmarshaller.setSchema(javax.xml.validation.Schema) 7ea9348d> @throws:UnsupportedOperationException could be thrown if this method is invoked on an Unmarshaller created from a JAXBContext referencing JAXB 1.0 mapped classes. 
<javax.xml.bind|Unmarshaller.getSchema() f334cd8d> Get the JAXP 1.3 {@link javax.xml.validation.Schema Schema} object being used to perform unmarshal-time validation. 
<javax.xml.bind|Unmarshaller.getSchema() 14b692ec> If there is no Schema set on the unmarshaller, then this method will return null indicating that unmarshal-time validation will not be performed. 
<javax.xml.bind|Unmarshaller.getSchema() 34f31228> This method provides replacement functionality for the deprecated {@link #isValidating()} API as well as access to the Schema object. 
<javax.xml.bind|Unmarshaller.getSchema() a497d314> To determine if the Unmarshaller has validation enabled, simply test the return type for null: boolean isValidating = u.getSchema()!=null; . 
<javax.xml.bind|Unmarshaller.getSchema() 3e578064> @return:the Schema object being used to perform unmarshal-time validation or null if not present. 
<javax.xml.bind|Unmarshaller.getSchema() 7ea9348d> @throws:UnsupportedOperationException could be thrown if this method is invoked on an Unmarshaller created from a JAXBContext referencing JAXB 1.0 mapped classes. 
<javax.xml.bind|Unmarshaller.setAdapter(javax.xml.bind.annotation.adapters.XmlAdapter) e75c2a5c> Associates a configured instance of {@link XmlAdapter} with this unmarshaller. 
<javax.xml.bind|Unmarshaller.setAdapter(javax.xml.bind.annotation.adapters.XmlAdapter) 20a39242> This is a convenience method that invokes setAdapter(adapter.getClass(),adapter);. 
<javax.xml.bind|Unmarshaller.setAdapter(javax.xml.bind.annotation.adapters.XmlAdapter) f018c3a0> @throws:IllegalArgumentException if the adapter parameter is null. 
<javax.xml.bind|Unmarshaller.setAdapter(javax.xml.bind.annotation.adapters.XmlAdapter) d1fd592> @throws:UnsupportedOperationException if invoked agains a JAXB 1.0 implementation. 
<javax.xml.bind|Unmarshaller.setAdapter(java.lang.Class,javax.xml.bind.annotation.adapters.XmlAdapter) e75c2a5c> Associates a configured instance of {@link XmlAdapter} with this unmarshaller. 
<javax.xml.bind|Unmarshaller.setAdapter(java.lang.Class,javax.xml.bind.annotation.adapters.XmlAdapter) 4410b315> Every unmarshaller internally maintains a {@link java.util.Map}&lt;{@link Class},{@link XmlAdapter}>, which it uses for unmarshalling classes whose fields/methods are annotated with {@link javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter}. 
<javax.xml.bind|Unmarshaller.setAdapter(java.lang.Class,javax.xml.bind.annotation.adapters.XmlAdapter) 49d6379d> This method allows applications to use a configured instance of {@link XmlAdapter}. 
<javax.xml.bind|Unmarshaller.setAdapter(java.lang.Class,javax.xml.bind.annotation.adapters.XmlAdapter) 2e7e3f76> When an instance of an adapter is not given, an unmarshaller will create one by invoking its default constructor. 
<javax.xml.bind|Unmarshaller.setAdapter(java.lang.Class,javax.xml.bind.annotation.adapters.XmlAdapter) 3d7752b3> @throws:IllegalArgumentException if the type parameter is null. 
<javax.xml.bind|Unmarshaller.setAdapter(java.lang.Class,javax.xml.bind.annotation.adapters.XmlAdapter) d1fd592> @throws:UnsupportedOperationException if invoked agains a JAXB 1.0 implementation. 
<javax.xml.bind|Unmarshaller.getAdapter(java.lang.Class) 31525857> Gets the adapter associated with the specified type. 
<javax.xml.bind|Unmarshaller.getAdapter(java.lang.Class) e5240965> This is the reverse operation of the {@link #setAdapter} method. 
<javax.xml.bind|Unmarshaller.getAdapter(java.lang.Class) 3d7752b3> @throws:IllegalArgumentException if the type parameter is null. 
<javax.xml.bind|Unmarshaller.getAdapter(java.lang.Class) d1fd592> @throws:UnsupportedOperationException if invoked agains a JAXB 1.0 implementation. 
<javax.xml.bind|Unmarshaller.setAttachmentUnmarshaller(javax.xml.bind.attachment.AttachmentUnmarshaller) d284643e> Associate a context that resolves cid's, content-id URIs, to binary data passed as attachments. 
<javax.xml.bind|Unmarshaller.setAttachmentUnmarshaller(javax.xml.bind.attachment.AttachmentUnmarshaller) e7bcc92e> Unmarshal time validation, enabled via {@link #setSchema(Schema)}, must be supported even when unmarshaller is performing XOP processing. 
<javax.xml.bind|Unmarshaller.setAttachmentUnmarshaller(javax.xml.bind.attachment.AttachmentUnmarshaller) c4f38f3> . @throws:IllegalStateException if attempt to concurrently call this method during a unmarshal operation. 
<javax.xml.bind|Unmarshaller.setListener(javax.xml.bind.Unmarshaller.Listener) 4b9239f0>  Register unmarshal event callback {@link Listener} with this {@link Unmarshaller}. 
<javax.xml.bind|Unmarshaller.setListener(javax.xml.bind.Unmarshaller.Listener) 2f85eb55> There is only one Listener per Unmarshaller. 
<javax.xml.bind|Unmarshaller.setListener(javax.xml.bind.Unmarshaller.Listener) a10859c4> Setting a Listener replaces the previous set Listener. 
<javax.xml.bind|Unmarshaller.setListener(javax.xml.bind.Unmarshaller.Listener) d80282c5> One can unregister current Listener by setting listener to null. 
<javax.xml.bind|Unmarshaller.getListener() 20e80fd> Return {@link Listener} registered with this {@link Unmarshaller}. 
<javax.xml.bind|Unmarshaller.getListener() a13035b6> @return:registered {@link Listener} or null if no Listener is registered with this Unmarshaller. 
<javax.xml.bind|Unmarshaller.Listener e16aee0f>  Register an instance of an implementation of this class with {@link Unmarshaller} to externally listen for unmarshal events. 
<javax.xml.bind|Unmarshaller.Listener e815a439> This class enables pre and post processing of an instance of a JAXB mapped class as XML data is unmarshalled into it. 
<javax.xml.bind|Unmarshaller.Listener f01f3be3> The event callbacks are called when unmarshalling XML content into a JAXBElement instance or a JAXB mapped class that represents a complex type definition. 
<javax.xml.bind|Unmarshaller.Listener a8c85879> The event callbacks are not called when unmarshalling to an instance of a Java datatype that represents a simple type definition. 
<javax.xml.bind|Unmarshaller.Listener 5385ea95> External listener is one of two different mechanisms for defining unmarshal event callbacks. 
<javax.xml.bind|Unmarshaller.Listener 8228c938> See Unmarshal Event Callbacks for an overview. 
<javax.xml.bind|Unmarshaller.Listener a668a7c5> (@link #setListener(Listener)} (@link #getListener()}. 
<javax.xml.bind|Unmarshaller.Listener.beforeUnmarshal(java.lang.Object,java.lang.Object) 8a6737ef>  Callback method invoked before unmarshalling into target. 
<javax.xml.bind|Unmarshaller.Listener.beforeUnmarshal(java.lang.Object,java.lang.Object) e489c64c> This method is invoked immediately after target was created and before the unmarshalling of this object begins. 
<javax.xml.bind|Unmarshaller.Listener.beforeUnmarshal(java.lang.Object,java.lang.Object) bcbdeb6c> Note that if the class of target defines its own beforeUnmarshal method, the class specific callback method is invoked before this method is invoked. 
<javax.xml.bind|Unmarshaller.Listener.afterUnmarshal(java.lang.Object,java.lang.Object) 52f5ff90>  Callback method invoked after unmarshalling XML data into target. 
<javax.xml.bind|Unmarshaller.Listener.afterUnmarshal(java.lang.Object,java.lang.Object) f8b9013> This method is invoked after all the properties (except IDREF) are unmarshalled into target, but before target is set into its parent object. 
<javax.xml.bind|Unmarshaller.Listener.afterUnmarshal(java.lang.Object,java.lang.Object) de619af6> Note that if the class of target defines its own afterUnmarshal method, the class specific callback method is invoked before this method is invoked. 
<javax.xml.bind|UnmarshalException cb9c3e61> This exception indicates that an error has occurred while performing an unmarshal operation that prevents the JAXB Provider from completing the operation. 
<javax.xml.bind|UnmarshalException 638bfb08> The ValidationEventHandler can cause this exception to be thrown during the unmarshal operations. 
<javax.xml.bind|UnmarshalException 67b832fb> See {@link ValidationEventHandler#handleEvent(ValidationEvent) ValidationEventHandler.handleEvent(ValidationEvent)}. 
<javax.xml.bind|UnmarshalException.UnmarshalException(java.lang.String) bd02fd4d> Construct an UnmarshalException with the specified detail message. 
<javax.xml.bind|UnmarshalException.UnmarshalException(java.lang.String) 9737b3ac> The errorCode and linkedException will default to null. 
<javax.xml.bind|UnmarshalException.UnmarshalException(java.lang.String,java.lang.String) 14d1a759> Construct an UnmarshalException with the specified detail message and vendor specific errorCode. 
<javax.xml.bind|UnmarshalException.UnmarshalException(java.lang.String,java.lang.String) bd427e8b> The linkedException will default to null. 
<javax.xml.bind|UnmarshalException.UnmarshalException(java.lang.Throwable) 3c80a65d> Construct an UnmarshalException with a linkedException. 
<javax.xml.bind|UnmarshalException.UnmarshalException(java.lang.Throwable) 78efbd0d> The detail message and vendor specific errorCode will default to null. 
<javax.xml.bind|UnmarshalException.UnmarshalException(java.lang.String,java.lang.Throwable) b2d9d641> Construct an UnmarshalException with the specified detail message and linkedException. 
<javax.xml.bind|UnmarshalException.UnmarshalException(java.lang.String,java.lang.Throwable) 5959e1bc> The errorCode will default to null. 
<javax.xml.bind|UnmarshalException.UnmarshalException(java.lang.String,java.lang.String,java.lang.Throwable) b2928a6b> Construct an UnmarshalException with the specified detail message, vendor specific errorCode, and linkedException. 
<javax.xml.bind|TypeConstraintException 9b5ab7db> This exception indicates that a violation of a dynamically checked type constraint was detected. 
<javax.xml.bind|TypeConstraintException 7d07d133> This exception can be thrown by the generated setter methods of the schema derived Java content classes. 
<javax.xml.bind|TypeConstraintException 900ab73e> However, since fail-fast validation is an optional feature for JAXB Providers to support, not all setter methods will throw this exception when a type constraint is violated. 
<javax.xml.bind|TypeConstraintException b61659a0> If this exception is throw while invoking a fail-fast setter, the value of the property is guaranteed to remain unchanged, as if the setter were never called. 
<javax.xml.bind|TypeConstraintException.TypeConstraintException(java.lang.String) c41e7c6a> Construct a TypeConstraintException with the specified detail message. 
<javax.xml.bind|TypeConstraintException.TypeConstraintException(java.lang.String) 9737b3ac> The errorCode and linkedException will default to null. 
<javax.xml.bind|TypeConstraintException.TypeConstraintException(java.lang.String,java.lang.String) ee4d4c76> Construct a TypeConstraintException with the specified detail message and vendor specific errorCode. 
<javax.xml.bind|TypeConstraintException.TypeConstraintException(java.lang.String,java.lang.String) bd427e8b> The linkedException will default to null. 
<javax.xml.bind|TypeConstraintException.TypeConstraintException(java.lang.Throwable) f70f6920> Construct a TypeConstraintException with a linkedException. 
<javax.xml.bind|TypeConstraintException.TypeConstraintException(java.lang.Throwable) 78efbd0d> The detail message and vendor specific errorCode will default to null. 
<javax.xml.bind|TypeConstraintException.TypeConstraintException(java.lang.String,java.lang.Throwable) bd08b304> Construct a TypeConstraintException with the specified detail message and linkedException. 
<javax.xml.bind|TypeConstraintException.TypeConstraintException(java.lang.String,java.lang.Throwable) 5959e1bc> The errorCode will default to null. 
<javax.xml.bind|TypeConstraintException.TypeConstraintException(java.lang.String,java.lang.String,java.lang.Throwable) 55b255ee> Construct a TypeConstraintException with the specified detail message, vendor specific errorCode, and linkedException. 
<javax.xml.bind|TypeConstraintException.getErrorCode() ccd45337> Get the vendor specific error code. 
<javax.xml.bind|TypeConstraintException.getErrorCode() 6f0e9110> @return:a string specifying the vendor specific error code. 
<javax.xml.bind|TypeConstraintException.getLinkedException() 25f6b7a3> Get the linked exception. 
<javax.xml.bind|TypeConstraintException.getLinkedException() ae8a3f64> @return:the linked Exception, null if none exists. 
<javax.xml.bind|TypeConstraintException.setLinkedException(java.lang.Throwable) 934f3a24> Add a linked Exception. 
<javax.xml.bind|TypeConstraintException.toString() 8c37da5> Returns a short description of this TypeConstraintException. 
<javax.xml.bind|TypeConstraintException.printStackTrace(java.io.PrintStream) 1942a7c8> Prints this TypeConstraintException and its stack trace (including the stack trace of the linkedException if it is non-null) to the PrintStream. 
<javax.xml.bind|TypeConstraintException.printStackTrace() f130cb16> Prints this TypeConstraintException and its stack trace (including the stack trace of the linkedException if it is non-null) to System.err. 
<javax.xml.bind|SchemaOutputResolver b872a08a> Controls where a JAXB implementation puts the generates schema files. 
<javax.xml.bind|SchemaOutputResolver bb5c4e1c> An implementation of this abstract class has to be provided by the calling application to generate schemas. 
<javax.xml.bind|SchemaOutputResolver 5ef44577> This is a class, not an interface so as to allow future versions to evolve without breaking the compatibility. 
<javax.xml.bind|SchemaOutputResolver.createOutput(java.lang.String,java.lang.String) 7ddc7651> Decides where the schema file (of the given namespace URI) will be written, and return it as a {@link Result} object. 
<javax.xml.bind|SchemaOutputResolver.createOutput(java.lang.String,java.lang.String) d9bdcbdd> This method is called only once for any given namespace. 
<javax.xml.bind|SchemaOutputResolver.createOutput(java.lang.String,java.lang.String) 5a6fae63> IOW, all the components in one namespace is always written into the same schema document. 
<javax.xml.bind|SchemaOutputResolver.createOutput(java.lang.String,java.lang.String) 1ca2df> @return:a {@link Result} object that encapsulates the actual destination of the schema. 
<javax.xml.bind|SchemaOutputResolver.createOutput(java.lang.String,java.lang.String) d9f63109> If the {@link Result} object has a system ID, it must be an absolute system ID. 
<javax.xml.bind|SchemaOutputResolver.createOutput(java.lang.String,java.lang.String) 4590d814> Those system IDs are relativized by the caller and used for &lt;xs:import> statements. 
<javax.xml.bind|SchemaOutputResolver.createOutput(java.lang.String,java.lang.String) eac5b0c4> If the {@link Result} object does not have a system ID, a schema for the namespace URI is generated but it won't be explicitly &lt;xs:import>ed from other schemas. 
<javax.xml.bind|SchemaOutputResolver.createOutput(java.lang.String,java.lang.String) 7aea7851> If {@code null} is returned, the schema generation for this namespace URI will be skipped. 
<javax.xml.bind|PropertyException 9faf97a9> This exception indicates that an error was encountered while getting or setting a property. 
<javax.xml.bind|PropertyException.PropertyException(java.lang.String) f1217db2> Construct a PropertyException with the specified detail message. 
<javax.xml.bind|PropertyException.PropertyException(java.lang.String) 9737b3ac> The errorCode and linkedException will default to null. 
<javax.xml.bind|PropertyException.PropertyException(java.lang.String,java.lang.String) ef4bdbe> Construct a PropertyException with the specified detail message and vendor specific errorCode. 
<javax.xml.bind|PropertyException.PropertyException(java.lang.String,java.lang.String) bd427e8b> The linkedException will default to null. 
<javax.xml.bind|PropertyException.PropertyException(java.lang.Throwable) e272bad8> Construct a PropertyException with a linkedException. 
<javax.xml.bind|PropertyException.PropertyException(java.lang.Throwable) 78efbd0d> The detail message and vendor specific errorCode will default to null. 
<javax.xml.bind|PropertyException.PropertyException(java.lang.String,java.lang.Throwable) 3bc194bc> Construct a PropertyException with the specified detail message and linkedException. 
<javax.xml.bind|PropertyException.PropertyException(java.lang.String,java.lang.Throwable) 5959e1bc> The errorCode will default to null. 
<javax.xml.bind|PropertyException.PropertyException(java.lang.String,java.lang.String,java.lang.Throwable) 2081d5a6> Construct a PropertyException with the specified detail message, vendor specific errorCode, and linkedException. 
<javax.xml.bind|PropertyException.PropertyException(java.lang.String,java.lang.Object) 70155fc5> Construct a PropertyException whose message field is set based on the name of the property and value.toString(). 
<javax.xml.bind|PrintConversionEvent 29ae0a59> This event indicates that a problem was encountered while converting data from the Java content tree into its lexical representation. 
<javax.xml.bind|ParseConversionEvent 8d898a7e> This event indicates that a problem was encountered while converting a string from the XML data into a value of the target Java data type. 
<javax.xml.bind|NotIdentifiableEvent 737c0adc> This event indicates that a problem was encountered resolving an ID/IDREF. 
<javax.xml.bind|Marshaller ead826b0>  The Marshaller class is responsible for governing the process of serializing Java content trees back into XML data. 
<javax.xml.bind|Marshaller 757d8e96> It provides the basic marshalling methods: Assume the following setup code for all following code fragments: JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" ); Unmarshaller u = jc.createUnmarshaller(); Object element = u.unmarshal( new File( "foo.xml" ) ); Marshaller m = jc.createMarshaller(); Marshalling to a File: OutputStream os = new FileOutputStream( "nosferatu.xml" ); m.marshal( element, os ); Marshalling to a SAX ContentHandler: // assume MyContentHandler instanceof ContentHandler m.marshal( element, new MyContentHandler() ); Marshalling to a DOM Node: DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setNamespaceAware(true); DocumentBuilder db = dbf.newDocumentBuilder(); Document doc = db.newDocument(); m.marshal( element, doc ); Marshalling to a java.io.OutputStream: m.marshal( element, System.out ); Marshalling to a java.io.Writer: m.marshal( element, new PrintWriter( System.out ) ); Marshalling to a javax.xml.transform.SAXResult: // assume MyContentHandler instanceof ContentHandler SAXResult result = new SAXResult( new MyContentHandler() ); m.marshal( element, result ); Marshalling to a javax.xml.transform.DOMResult: DOMResult result = new DOMResult(); m.marshal( element, result ); Marshalling to a javax.xml.transform.StreamResult: StreamResult result = new StreamResult( System.out ); m.marshal( element, result ); Marshalling to a javax.xml.stream.XMLStreamWriter: XMLStreamWriter xmlStreamWriter = XMLOutputFactory.newInstance().createXMLStreamWriter( ... ); m.marshal( element, xmlStreamWriter ); Marshalling to a javax.xml.stream.XMLEventWriter: XMLEventWriter xmlEventWriter = XMLOutputFactory.newInstance().createXMLEventWriter( ... ); m.marshal( element, xmlEventWriter ); Marshalling content tree rooted by a JAXB element The first parameter of the overloaded Marshaller.marshal(java.lang.Object, ...) methods must be a JAXB element as computed by {@link JAXBIntrospector#isElement(java.lang.Object)}; otherwise, a Marshaller.marshal method must throw a {@link MarshalException}. 
<javax.xml.bind|Marshaller b910e4d6> There exist two mechanisms to enable marshalling an instance that is not a JAXB element. 
<javax.xml.bind|Marshaller 9b6205d0> One method is to wrap the instance as a value of a {@link JAXBElement}, and pass the wrapper element as the first parameter to a Marshaller.marshal method. 
<javax.xml.bind|Marshaller 501a6f8a> For java to schema binding, it is also possible to simply annotate the instance's class with &#64;{@link XmlRootElement}. 
<javax.xml.bind|Marshaller b2aa99c7> Encoding By default, the Marshaller will use UTF-8 encoding when generating XML data to a java.io.OutputStream, or a java.io.Writer. 
<javax.xml.bind|Marshaller 1a7f3d11> Use the {@link #setProperty(String,Object) setProperty} API to change the output encoding used during these marshal operations. 
<javax.xml.bind|Marshaller f540881e> Client applications are expected to supply a valid character encoding name as defined in the W3C XML 1.0 Recommendation and supported by your Java Platform. 
<javax.xml.bind|Marshaller af094efe> Validation and Well-Formedness Client applications are not required to validate the Java content tree prior to calling any of the marshal API's. 
<javax.xml.bind|Marshaller 3fa92830> Furthermore, there is no requirement that the Java content tree be valid with respect to its original schema in order to marshal it back into XML data. 
<javax.xml.bind|Marshaller c26d65af> Different JAXB Providers will support marshalling invalid Java content trees at varying levels, however all JAXB Providers must be able to marshal a valid content tree back to XML data. 
<javax.xml.bind|Marshaller e82bf841> A JAXB Provider must throw a MarshalException when it is unable to complete the marshal operation due to invalid content. 
<javax.xml.bind|Marshaller b20b5035> Some JAXB Providers will fully allow marshalling invalid content, others will fail on the first validation error. 
<javax.xml.bind|Marshaller 5b07b485> Even when schema validation is not explictly enabled for the marshal operation, it is possible that certain types of validation events will be detected during the operation. 
<javax.xml.bind|Marshaller b46f769e> Validation events will be reported to the registered event handler. 
<javax.xml.bind|Marshaller bee42199> If the client application has not registered an event handler prior to invoking one of the marshal API's, then events will be delivered to a default event handler which will terminate the marshal operation after encountering the first error or fatal error. 
<javax.xml.bind|Marshaller 60d15960> Note that for JAXB 2.0 and later versions, {@link javax.xml.bind.helpers.DefaultValidationEventHandler} is no longer used. 
<javax.xml.bind|Marshaller 5348c639> Supported Properties All JAXB Providers are required to support the following set of properties. 
<javax.xml.bind|Marshaller 58460c17> Some providers may support additional properties. 
<javax.xml.bind|Marshaller e9e6c6ba> jaxb.encoding - value must be a java.lang.String The output encoding to use when marshalling the XML data. 
<javax.xml.bind|Marshaller 7d2fc8b> The Marshaller will use "UTF-8" by default if this property is not specified. 
<javax.xml.bind|Marshaller 3c7323a8> jaxb.formatted.output - value must be a java.lang.Boolean This property controls whether or not the Marshaller will format the resulting XML data with line breaks and indentation. 
<javax.xml.bind|Marshaller c044943a> A true value for this property indicates human readable indented xml data, while a false value indicates unformatted xml data. 
<javax.xml.bind|Marshaller e74ded97> The Marshaller will default to false (unformatted) if this property is not specified. 
<javax.xml.bind|Marshaller 1e9f2fea> jaxb.schemaLocation - value must be a java.lang.String This property allows the client application to specify an xsi:schemaLocation attribute in the generated XML data. 
<javax.xml.bind|Marshaller 9007b61a> The format of the schemaLocation attribute value is discussed in an easy to understand, non-normative form in Section 5.6 of the W3C XML Schema Part 0: Primer and specified in Section 2.6 of the W3C XML Schema Part 1: Structures. 
<javax.xml.bind|Marshaller 1efe5e8a> jaxb.noNamespaceSchemaLocation - value must be a java.lang.String This property allows the client application to specify an xsi:noNamespaceSchemaLocation attribute in the generated XML data. 
<javax.xml.bind|Marshaller 113402ef> jaxb.fragment - value must be a java.lang.Boolean This property determines whether or not document level events will be generated by the Marshaller. 
<javax.xml.bind|Marshaller 7250b786> If the property is not specified, the default is false. 
<javax.xml.bind|Marshaller 4abf3bff> This property has different implications depending on which marshal api you are using - when this property is set to true: {@link #marshal(Object,org.xml.sax.ContentHandler) marshal(Object,ContentHandler)} - the Marshaller won't invoke {@link org.xml.sax.ContentHandler#startDocument()} and {@link org.xml.sax.ContentHandler#endDocument()}. 
<javax.xml.bind|Marshaller 6cb2e76> {@link #marshal(Object,org.w3c.dom.Node) marshal(Object,Node)} - the property has no effect on this API. 
<javax.xml.bind|Marshaller 3fe904ed> {@link #marshal(Object,java.io.OutputStream) marshal(Object,OutputStream)} - the Marshaller won't generate an xml declaration. 
<javax.xml.bind|Marshaller b6fe2205> {@link #marshal(Object,java.io.Writer) marshal(Object,Writer)} - the Marshaller won't generate an xml declaration. 
<javax.xml.bind|Marshaller f7ac1a57> {@link #marshal(Object,javax.xml.transform.Result) marshal(Object,Result)} - depends on the kind of Result object, see semantics for Node, ContentHandler, and Stream APIs {@link #marshal(Object,javax.xml.stream.XMLEventWriter) marshal(Object,XMLEventWriter)} - the Marshaller will not generate {@link javax.xml.stream.events.XMLEvent#START_DOCUMENT} and {@link javax.xml.stream.events.XMLEvent#END_DOCUMENT} events. 
<javax.xml.bind|Marshaller fefd427e> {@link #marshal(Object,javax.xml.stream.XMLStreamWriter) marshal(Object,XMLStreamWriter)} - the Marshaller will not generate {@link javax.xml.stream.events.XMLEvent#START_DOCUMENT} and {@link javax.xml.stream.events.XMLEvent#END_DOCUMENT} events. 
<javax.xml.bind|Marshaller 4971c915> Marshal Event Callbacks "The {@link Marshaller} provides two styles of callback mechanisms that allow application specific processing during key points in the unmarshalling process. 
<javax.xml.bind|Marshaller 8e7edae1> In 'class defined' event callbacks, application specific code placed in JAXB mapped classes is triggered during marshalling. 
<javax.xml.bind|Marshaller f7ee34bd> 'External listeners' allow for centralized processing of marshal events in one callback method rather than by type event callbacks. 
<javax.xml.bind|Marshaller 519ac1e> Class defined event callback methods allow any JAXB mapped class to specify its own specific callback methods by defining methods with the following method signatures: // Invoked by Marshaller after it has created an instance of this object. 
<javax.xml.bind|Marshaller d63259b4> boolean beforeMarshal(Marshaller, Object parent); // Invoked by Marshaller after it has marshalled all properties of this object. 
<javax.xml.bind|Marshaller 9b19fe3b> void afterMmarshal(Marshaller, Object parent); The class defined event callback methods should be used when the callback method requires access to non-public methods and/or fields of the class. 
<javax.xml.bind|Marshaller eb4fb928> The external listener callback mechanism enables the registration of a {@link Listener} instance with a {@link Marshaller#setListener(Listener)}. 
<javax.xml.bind|Marshaller 969b22bd> The external listener receives all callback events, allowing for more centralized processing than per class defined callback methods. 
<javax.xml.bind|Marshaller b22430e8> The 'class defined' and external listener event callback methods are independent of each other, both can be called for one event. 
<javax.xml.bind|Marshaller 75b31275> The invocation ordering when both listener callback methods exist is defined in {@link Listener#beforeMarshal(Object)} and {@link Listener#afterMarshal(Object)}. 
<javax.xml.bind|Marshaller 96b3e7eb> An event callback method throwing an exception terminates the current marshal process. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,javax.xml.transform.Result) 1de91074> Marshal the content tree rooted at jaxbElement into the specified javax.xml.transform.Result. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,javax.xml.transform.Result) b4b5043c> All JAXB Providers must at least support {@link javax.xml.transform.dom.DOMResult}, {@link javax.xml.transform.sax.SAXResult}, and {@link javax.xml.transform.stream.StreamResult}. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,javax.xml.transform.Result) 73ecd14d> It can support other derived classes of Result as well. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,javax.xml.transform.Result) c9d34777> @throws:JAXBException If any unexpected problem occurs during the marshalling. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,javax.xml.transform.Result) 6b9da1> @throws:MarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Marshaller is unable to marshal obj (or any object reachable from obj). 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,javax.xml.transform.Result) 8ae780b5> See Marshalling a JAXB element. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,javax.xml.transform.Result) e55c17d2> @throws:IllegalArgumentException If any of the method parameters are null. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,java.io.OutputStream) 89f7a1ce> Marshal the content tree rooted at jaxbElement into an output stream. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,java.io.OutputStream) c9d34777> @throws:JAXBException If any unexpected problem occurs during the marshalling. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,java.io.OutputStream) 6b9da1> @throws:MarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Marshaller is unable to marshal obj (or any object reachable from obj). 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,java.io.OutputStream) 8ae780b5> See Marshalling a JAXB element. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,java.io.OutputStream) e55c17d2> @throws:IllegalArgumentException If any of the method parameters are null. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,java.io.Writer) 326032c1> Marshal the content tree rooted at jaxbElement into a Writer. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,java.io.Writer) c9d34777> @throws:JAXBException If any unexpected problem occurs during the marshalling. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,java.io.Writer) 6b9da1> @throws:MarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Marshaller is unable to marshal obj (or any object reachable from obj). 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,java.io.Writer) 8ae780b5> See Marshalling a JAXB element. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,java.io.Writer) e55c17d2> @throws:IllegalArgumentException If any of the method parameters are null. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,org.xml.sax.ContentHandler) 7bb7ddfc> Marshal the content tree rooted at jaxbElement into SAX2 events. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,org.xml.sax.ContentHandler) c9d34777> @throws:JAXBException If any unexpected problem occurs during the marshalling. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,org.xml.sax.ContentHandler) 6b9da1> @throws:MarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Marshaller is unable to marshal obj (or any object reachable from obj). 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,org.xml.sax.ContentHandler) 8ae780b5> See Marshalling a JAXB element. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,org.xml.sax.ContentHandler) e55c17d2> @throws:IllegalArgumentException If any of the method parameters are null. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,org.w3c.dom.Node) 32577cef> Marshal the content tree rooted at jaxbElement into a DOM tree. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,org.w3c.dom.Node) c9d34777> @throws:JAXBException If any unexpected problem occurs during the marshalling. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,org.w3c.dom.Node) 66d234ad> @throws:MarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Marshaller is unable to marshal jaxbElement (or any object reachable from jaxbElement). 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,org.w3c.dom.Node) 8ae780b5> See Marshalling a JAXB element. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,org.w3c.dom.Node) e55c17d2> @throws:IllegalArgumentException If any of the method parameters are null. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,javax.xml.stream.XMLStreamWriter) 584b6df4> Marshal the content tree rooted at jaxbElement into a {@link javax.xml.stream.XMLStreamWriter}. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,javax.xml.stream.XMLStreamWriter) c9d34777> @throws:JAXBException If any unexpected problem occurs during the marshalling. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,javax.xml.stream.XMLStreamWriter) 6b9da1> @throws:MarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Marshaller is unable to marshal obj (or any object reachable from obj). 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,javax.xml.stream.XMLStreamWriter) 8ae780b5> See Marshalling a JAXB element. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,javax.xml.stream.XMLStreamWriter) e55c17d2> @throws:IllegalArgumentException If any of the method parameters are null. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,javax.xml.stream.XMLEventWriter) 3298087c> Marshal the content tree rooted at jaxbElement into a {@link javax.xml.stream.XMLEventWriter}. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,javax.xml.stream.XMLEventWriter) c9d34777> @throws:JAXBException If any unexpected problem occurs during the marshalling. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,javax.xml.stream.XMLEventWriter) 6b9da1> @throws:MarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Marshaller is unable to marshal obj (or any object reachable from obj). 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,javax.xml.stream.XMLEventWriter) 8ae780b5> See Marshalling a JAXB element. 
<javax.xml.bind|Marshaller.marshal(java.lang.Object,javax.xml.stream.XMLEventWriter) e55c17d2> @throws:IllegalArgumentException If any of the method parameters are null. 
<javax.xml.bind|Marshaller.getNode(java.lang.Object) ffe8a047> Get a DOM tree view of the content tree(Optional). 
<javax.xml.bind|Marshaller.getNode(java.lang.Object) 850eaf71> If the returned DOM tree is updated, these changes are also visible in the content tree. 
<javax.xml.bind|Marshaller.getNode(java.lang.Object) c2c156f0> Use {@link #marshal(Object, org.w3c.dom.Node)} to force a deep copy of the content tree to a DOM representation. 
<javax.xml.bind|Marshaller.getNode(java.lang.Object) 252b440d> @return:the DOM tree view of the contentTree. 
<javax.xml.bind|Marshaller.getNode(java.lang.Object) 22571191> @throws:UnsupportedOperationException If the JAXB provider implementation does not support a DOM view of the content tree. 
<javax.xml.bind|Marshaller.getNode(java.lang.Object) e55c17d2> @throws:IllegalArgumentException If any of the method parameters are null. 
<javax.xml.bind|Marshaller.getNode(java.lang.Object) 24f789c9> @throws:JAXBException If any unexpected problem occurs. 
<javax.xml.bind|Marshaller.setProperty(java.lang.String,java.lang.Object) 9a0ab5ab> Set the particular property in the underlying implementation of Marshaller. 
<javax.xml.bind|Marshaller.setProperty(java.lang.String,java.lang.Object) 33bae51e> This method can only be used to set one of the standard JAXB defined properties above or a provider specific property. 
<javax.xml.bind|Marshaller.setProperty(java.lang.String,java.lang.Object) 20c199f6> Attempting to set an undefined property will result in a PropertyException being thrown. 
<javax.xml.bind|Marshaller.setProperty(java.lang.String,java.lang.Object) 25e3b185> See Supported Properties. 
<javax.xml.bind|Marshaller.setProperty(java.lang.String,java.lang.Object) 83af0b54> @throws:PropertyException when there is an error processing the given property or value. 
<javax.xml.bind|Marshaller.setProperty(java.lang.String,java.lang.Object) fd0d9b0b> @throws:IllegalArgumentException If the name parameter is null. 
<javax.xml.bind|Marshaller.getProperty(java.lang.String) 414c3837> Get the particular property in the underlying implementation of Marshaller. 
<javax.xml.bind|Marshaller.getProperty(java.lang.String) 10a5f4aa> This method can only be used to get one of the standard JAXB defined properties above or a provider specific property. 
<javax.xml.bind|Marshaller.getProperty(java.lang.String) 893f95ea> Attempting to get an undefined property will result in a PropertyException being thrown. 
<javax.xml.bind|Marshaller.getProperty(java.lang.String) 25e3b185> See Supported Properties. 
<javax.xml.bind|Marshaller.getProperty(java.lang.String) d7ee175b> @return:the value of the requested property. 
<javax.xml.bind|Marshaller.getProperty(java.lang.String) 33b30015> @throws:PropertyException when there is an error retrieving the given property or value property name. 
<javax.xml.bind|Marshaller.getProperty(java.lang.String) fd0d9b0b> @throws:IllegalArgumentException If the name parameter is null. 
<javax.xml.bind|Marshaller.setEventHandler(javax.xml.bind.ValidationEventHandler) 126e3720> Allow an application to register a validation event handler. 
<javax.xml.bind|Marshaller.setEventHandler(javax.xml.bind.ValidationEventHandler) a9207c5d> The validation event handler will be called by the JAXB Provider if any validation errors are encountered during calls to any of the marshal API's. 
<javax.xml.bind|Marshaller.setEventHandler(javax.xml.bind.ValidationEventHandler) 784dcd65> If the client application does not register a validation event handler before invoking one of the marshal methods, then validation events will be handled by the default event handler which will terminate the marshal operation after the first error or fatal error is encountered. 
<javax.xml.bind|Marshaller.setEventHandler(javax.xml.bind.ValidationEventHandler) da4dd7> Calling this method with a null parameter will cause the Marshaller to revert back to the default default event handler. 
<javax.xml.bind|Marshaller.setEventHandler(javax.xml.bind.ValidationEventHandler) 778ea19b> @throws:JAXBException if an error was encountered while setting the event handler. 
<javax.xml.bind|Marshaller.getEventHandler() de7fd39f> Return the current event handler or the default event handler if one hasn't been set. 
<javax.xml.bind|Marshaller.getEventHandler() ef8f894b> @return:the current ValidationEventHandler or the default event handler if it hasn't been set. 
<javax.xml.bind|Marshaller.getEventHandler() 2fe6718a> @throws:JAXBException if an error was encountered while getting the current event handler. 
<javax.xml.bind|Marshaller.setAdapter(javax.xml.bind.annotation.adapters.XmlAdapter) 888d1726> Associates a configured instance of {@link XmlAdapter} with this marshaller. 
<javax.xml.bind|Marshaller.setAdapter(javax.xml.bind.annotation.adapters.XmlAdapter) 20a39242> This is a convenience method that invokes setAdapter(adapter.getClass(),adapter);. 
<javax.xml.bind|Marshaller.setAdapter(javax.xml.bind.annotation.adapters.XmlAdapter) f018c3a0> @throws:IllegalArgumentException if the adapter parameter is null. 
<javax.xml.bind|Marshaller.setAdapter(javax.xml.bind.annotation.adapters.XmlAdapter) d1fd592> @throws:UnsupportedOperationException if invoked agains a JAXB 1.0 implementation. 
<javax.xml.bind|Marshaller.setAdapter(java.lang.Class,javax.xml.bind.annotation.adapters.XmlAdapter) 888d1726> Associates a configured instance of {@link XmlAdapter} with this marshaller. 
<javax.xml.bind|Marshaller.setAdapter(java.lang.Class,javax.xml.bind.annotation.adapters.XmlAdapter) 48430b8b> Every marshaller internally maintains a {@link java.util.Map}&lt;{@link Class},{@link XmlAdapter}>, which it uses for marshalling classes whose fields/methods are annotated with {@link javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter}. 
<javax.xml.bind|Marshaller.setAdapter(java.lang.Class,javax.xml.bind.annotation.adapters.XmlAdapter) 49d6379d> This method allows applications to use a configured instance of {@link XmlAdapter}. 
<javax.xml.bind|Marshaller.setAdapter(java.lang.Class,javax.xml.bind.annotation.adapters.XmlAdapter) 6906e76> When an instance of an adapter is not given, a marshaller will create one by invoking its default constructor. 
<javax.xml.bind|Marshaller.setAdapter(java.lang.Class,javax.xml.bind.annotation.adapters.XmlAdapter) 3d7752b3> @throws:IllegalArgumentException if the type parameter is null. 
<javax.xml.bind|Marshaller.setAdapter(java.lang.Class,javax.xml.bind.annotation.adapters.XmlAdapter) d1fd592> @throws:UnsupportedOperationException if invoked agains a JAXB 1.0 implementation. 
<javax.xml.bind|Marshaller.getAdapter(java.lang.Class) 31525857> Gets the adapter associated with the specified type. 
<javax.xml.bind|Marshaller.getAdapter(java.lang.Class) e5240965> This is the reverse operation of the {@link #setAdapter} method. 
<javax.xml.bind|Marshaller.getAdapter(java.lang.Class) 3d7752b3> @throws:IllegalArgumentException if the type parameter is null. 
<javax.xml.bind|Marshaller.getAdapter(java.lang.Class) d1fd592> @throws:UnsupportedOperationException if invoked agains a JAXB 1.0 implementation. 
<javax.xml.bind|Marshaller.setAttachmentMarshaller(javax.xml.bind.attachment.AttachmentMarshaller) 2631ab91> Associate a context that enables binary data within an XML document to be transmitted as XML-binary optimized attachment. 
<javax.xml.bind|Marshaller.setAttachmentMarshaller(javax.xml.bind.attachment.AttachmentMarshaller) 3addd169> The attachment is referenced from the XML document content model by content-id URIs(cid) references stored within the xml document. 
<javax.xml.bind|Marshaller.setAttachmentMarshaller(javax.xml.bind.attachment.AttachmentMarshaller) 53d1b7db> @throws:IllegalStateException if attempt to concurrently call this method during a marshal operation. 
<javax.xml.bind|Marshaller.setSchema(javax.xml.validation.Schema) 605f5498> Specify the JAXP 1.3 {@link javax.xml.validation.Schema Schema} object that should be used to validate subsequent marshal operations against. 
<javax.xml.bind|Marshaller.setSchema(javax.xml.validation.Schema) afcae6cf> Passing null into this method will disable validation. 
<javax.xml.bind|Marshaller.setSchema(javax.xml.validation.Schema) e30a9ad2> This method allows the caller to validate the marshalled XML as it's marshalled. 
<javax.xml.bind|Marshaller.setSchema(javax.xml.validation.Schema) e88703b9> Initially this property is set to null. 
<javax.xml.bind|Marshaller.setSchema(javax.xml.validation.Schema) d1520fa7> @throws:UnsupportedOperationException could be thrown if this method is invoked on an Marshaller created from a JAXBContext referencing JAXB 1.0 mapped classes. 
<javax.xml.bind|Marshaller.getSchema() 4b39fd4d> Get the JAXP 1.3 {@link javax.xml.validation.Schema Schema} object being used to perform marshal-time validation. 
<javax.xml.bind|Marshaller.getSchema() 2290a97e> If there is no Schema set on the marshaller, then this method will return null indicating that marshal-time validation will not be performed. 
<javax.xml.bind|Marshaller.getSchema() a2a57104> @return:the Schema object being used to perform marshal-time validation or null if not present. 
<javax.xml.bind|Marshaller.getSchema() d1520fa7> @throws:UnsupportedOperationException could be thrown if this method is invoked on an Marshaller created from a JAXBContext referencing JAXB 1.0 mapped classes. 
<javax.xml.bind|Marshaller.setListener(javax.xml.bind.Marshaller.Listener) 50e6fcb2>  Register marshal event callback {@link Listener} with this {@link Marshaller}. 
<javax.xml.bind|Marshaller.setListener(javax.xml.bind.Marshaller.Listener) 721ad30d> There is only one Listener per Marshaller. 
<javax.xml.bind|Marshaller.setListener(javax.xml.bind.Marshaller.Listener) a10859c4> Setting a Listener replaces the previous set Listener. 
<javax.xml.bind|Marshaller.setListener(javax.xml.bind.Marshaller.Listener) d80282c5> One can unregister current Listener by setting listener to null. 
<javax.xml.bind|Marshaller.getListener() db99133b> Return {@link Listener} registered with this {@link Marshaller}. 
<javax.xml.bind|Marshaller.getListener() 54bd388c> @return:registered {@link Listener} or null if no Listener is registered with this Marshaller. 
<javax.xml.bind|Marshaller.JAXB_ENCODING cd5fcaf5> The name of the property used to specify the output encoding in the marshalled XML data. 
<javax.xml.bind|Marshaller.JAXB_FORMATTED_OUTPUT 86a61208> The name of the property used to specify whether or not the marshalled XML data is formatted with linefeeds and indentation. 
<javax.xml.bind|Marshaller.JAXB_SCHEMA_LOCATION 5df0ddbb> The name of the property used to specify the xsi:schemaLocation attribute value to place in the marshalled XML output. 
<javax.xml.bind|Marshaller.JAXB_NO_NAMESPACE_SCHEMA_LOCATION 72864b02> The name of the property used to specify the xsi:noNamespaceSchemaLocation attribute value to place in the marshalled XML output. 
<javax.xml.bind|Marshaller.JAXB_FRAGMENT 930074d2> The name of the property used to specify whether or not the marshaller will generate document level events (ie calling startDocument or endDocument). 
<javax.xml.bind|Marshaller.Listener 6d040c71>  Register an instance of an implementation of this class with a {@link Marshaller} to externally listen for marshal events. 
<javax.xml.bind|Marshaller.Listener 34afde7c> This class enables pre and post processing of each marshalled object. 
<javax.xml.bind|Marshaller.Listener 1b9e61f9> The event callbacks are called when marshalling from an instance that maps to an xml element or complex type definition. 
<javax.xml.bind|Marshaller.Listener 544fbc04> The event callbacks are not called when marshalling from an instance of a Java datatype that represents a simple type definition. 
<javax.xml.bind|Marshaller.Listener a9dfada1> External listener is one of two different mechanisms for defining marshal event callbacks. 
<javax.xml.bind|Marshaller.Listener c06d9950> See Marshal Event Callbacks for an overview. 
<javax.xml.bind|Marshaller.Listener.beforeMarshal(java.lang.Object) caa6a43c>  Callback method invoked before marshalling from source to XML. 
<javax.xml.bind|Marshaller.Listener.beforeMarshal(java.lang.Object) 53bf994f> This method is invoked just before marshalling process starts to marshal source. 
<javax.xml.bind|Marshaller.Listener.beforeMarshal(java.lang.Object) cf773084> Note that if the class of source defines its own beforeMarshal method, the class specific callback method is invoked just before this method is invoked. 
<javax.xml.bind|Marshaller.Listener.afterMarshal(java.lang.Object) d4f575db>  Callback method invoked after marshalling source to XML. 
<javax.xml.bind|Marshaller.Listener.afterMarshal(java.lang.Object) 91f8a5a6> This method is invoked after source and all its descendants have been marshalled. 
<javax.xml.bind|Marshaller.Listener.afterMarshal(java.lang.Object) 16ed258e> Note that if the class of source defines its own afterMarshal method, the class specific callback method is invoked just before this method is invoked. 
<javax.xml.bind|MarshalException 2fea8903> This exception indicates that an error has occurred while performing a marshal operation that the provider is unable to recover from. 
<javax.xml.bind|MarshalException 485e9d0> The ValidationEventHandler can cause this exception to be thrown during the marshal operations. 
<javax.xml.bind|MarshalException 67b832fb> See {@link ValidationEventHandler#handleEvent(ValidationEvent) ValidationEventHandler.handleEvent(ValidationEvent)}. 
<javax.xml.bind|MarshalException.MarshalException(java.lang.String) 9b26b14d> Construct a MarshalException with the specified detail message. 
<javax.xml.bind|MarshalException.MarshalException(java.lang.String) 9737b3ac> The errorCode and linkedException will default to null. 
<javax.xml.bind|MarshalException.MarshalException(java.lang.String,java.lang.String) bd0d5b59> Construct a MarshalException with the specified detail message and vendor specific errorCode. 
<javax.xml.bind|MarshalException.MarshalException(java.lang.String,java.lang.String) bd427e8b> The linkedException will default to null. 
<javax.xml.bind|MarshalException.MarshalException(java.lang.Throwable) dbdc725d> Construct a MarshalException with a linkedException. 
<javax.xml.bind|MarshalException.MarshalException(java.lang.Throwable) 78efbd0d> The detail message and vendor specific errorCode will default to null. 
<javax.xml.bind|MarshalException.MarshalException(java.lang.String,java.lang.Throwable) 991da241> Construct a MarshalException with the specified detail message and linkedException. 
<javax.xml.bind|MarshalException.MarshalException(java.lang.String,java.lang.Throwable) 5959e1bc> The errorCode will default to null. 
<javax.xml.bind|MarshalException.MarshalException(java.lang.String,java.lang.String,java.lang.Throwable) c041566b> Construct a MarshalException with the specified detail message, vendor specific errorCode, and linkedException. 
<javax.xml.bind|JAXBIntrospector bd817407> Provide access to JAXB xml binding data for a JAXB object. 
<javax.xml.bind|JAXBIntrospector cc872e64> Intially, the intent of this class is to just conceptualize how a JAXB application developer can access xml binding information, independent if binding model is java to schema or schema to java. 
<javax.xml.bind|JAXBIntrospector d3b83f47> Since accessing the XML element name related to a JAXB element is a highly requested feature, demonstrate access to this binding information. 
<javax.xml.bind|JAXBIntrospector 68d56240> The factory method to get a JAXBIntrospector instance is {@link JAXBContext#createJAXBIntrospector()}. 
<javax.xml.bind|JAXBIntrospector.isElement(java.lang.Object) 11b84c2> Return true iff object represents a JAXB element. 
<javax.xml.bind|JAXBIntrospector.isElement(java.lang.Object) 1074f7bc> Parameter object is a JAXB element for following cases: It is an instance of javax.xml.bind.JAXBElement. 
<javax.xml.bind|JAXBIntrospector.isElement(java.lang.Object) 9a015f4d> The class of object is annotated with &#64XmlRootElement. 
<javax.xml.bind|JAXBIntrospector.getElementName(java.lang.Object) 27561830> Get xml element qname for jaxbElement.. 
<javax.xml.bind|JAXBIntrospector.getElementName(java.lang.Object) 147dd392> @return:xml element qname associated with jaxbElement; null if jaxbElement is not a JAXB Element. 
<javax.xml.bind|JAXBIntrospector.getValue(java.lang.Object) 3c59d413> Get the element value of a JAXB element. 
<javax.xml.bind|JAXBIntrospector.getValue(java.lang.Object) 1c7b67c0> Convenience method to abstract whether working with either a javax.xml.bind.JAXBElement instance or an instance of &#64XmlRootElement annotated Java class.. 
<javax.xml.bind|JAXBIntrospector.getValue(java.lang.Object) e0174230> @return:The element value of the jaxbElement. 
<javax.xml.bind|JAXBException fe76361e> This is the root exception class for all JAXB exceptions. 
<javax.xml.bind|JAXBException.JAXBException(java.lang.String) bd0965ef> Construct a JAXBException with the specified detail message. 
<javax.xml.bind|JAXBException.JAXBException(java.lang.String) 9737b3ac> The errorCode and linkedException will default to null. 
<javax.xml.bind|JAXBException.JAXBException(java.lang.String,java.lang.String) 56868bfb> Construct a JAXBException with the specified detail message and vendor specific errorCode. 
<javax.xml.bind|JAXBException.JAXBException(java.lang.String,java.lang.String) bd427e8b> The linkedException will default to null. 
<javax.xml.bind|JAXBException.JAXBException(java.lang.Throwable) 541fe07b> Construct a JAXBException with a linkedException. 
<javax.xml.bind|JAXBException.JAXBException(java.lang.Throwable) 78efbd0d> The detail message and vendor specific errorCode will default to null. 
<javax.xml.bind|JAXBException.JAXBException(java.lang.String,java.lang.Throwable) 9cad145f> Construct a JAXBException with the specified detail message and linkedException. 
<javax.xml.bind|JAXBException.JAXBException(java.lang.String,java.lang.Throwable) 5959e1bc> The errorCode will default to null. 
<javax.xml.bind|JAXBException.JAXBException(java.lang.String,java.lang.String,java.lang.Throwable) 1a97bc09> Construct a JAXBException with the specified detail message, vendor specific errorCode, and linkedException. 
<javax.xml.bind|JAXBException.getErrorCode() ccd45337> Get the vendor specific error code. 
<javax.xml.bind|JAXBException.getErrorCode() 6f0e9110> @return:a string specifying the vendor specific error code. 
<javax.xml.bind|JAXBException.getLinkedException() 25f6b7a3> Get the linked exception. 
<javax.xml.bind|JAXBException.getLinkedException() ae8a3f64> @return:the linked Exception, null if none exists. 
<javax.xml.bind|JAXBException.setLinkedException(java.lang.Throwable) 934f3a24> Add a linked Exception. 
<javax.xml.bind|JAXBException.toString() e1cb0b84> Returns a short description of this JAXBException. 
<javax.xml.bind|JAXBException.printStackTrace(java.io.PrintStream) 3d0135fd> Prints this JAXBException and its stack trace (including the stack trace of the linkedException if it is non-null) to the PrintStream. 
<javax.xml.bind|JAXBException.printStackTrace() bdeef101> Prints this JAXBException and its stack trace (including the stack trace of the linkedException if it is non-null) to System.err. 
<javax.xml.bind|JAXBException.printStackTrace(java.io.PrintWriter) 3d03003a> Prints this JAXBException and its stack trace (including the stack trace of the linkedException if it is non-null) to the PrintWriter. 
<javax.xml.bind|JAXBElement 50977a23> JAXB representation of an Xml Element. 
<javax.xml.bind|JAXBElement 39c7fe48> This class represents information about an Xml Element from both the element declaration within a schema and the element instance value within an xml document with the following properties element's xml tag name value represents the element instance's atttribute(s) and content model element declaration's declaredType (xs:element @type attribute) scope of element declaration boolean nil property. 
<javax.xml.bind|JAXBElement d9312d6f> (element instance's xsi:nil attribute) The declaredType and scope property are the JAXB class binding for the xml type definition. 
<javax.xml.bind|JAXBElement 4e7aff2> Scope is either {@link GlobalScope} or the Java class representing the complex type definition containing the schema element declaration. 
<javax.xml.bind|JAXBElement 2c425685> There is a property constraint that if value is null, then nil must be true. 
<javax.xml.bind|JAXBElement dff1825f> The converse is not true to enable representing a nil element with attribute(s). 
<javax.xml.bind|JAXBElement 6e851754> If nil is true, it is possible that value is non-null so it can hold the value of the attributes associated with a nil element. 
<javax.xml.bind|JAXBElement.JAXBElement(javax.xml.namespace.QName,java.lang.Class,java.lang.Class,java.lang.Object) 336c285d> Construct an xml element instance.. 
<javax.xml.bind|JAXBElement.JAXBElement(javax.xml.namespace.QName,java.lang.Class,java.lang.Object) 336c285d> Construct an xml element instance. 
<javax.xml.bind|JAXBElement.JAXBElement(javax.xml.namespace.QName,java.lang.Class,java.lang.Object) 403b51b8> This is just a convenience method for new JAXBElement(name,declaredType,GlobalScope.class,value). 
<javax.xml.bind|JAXBElement.getDeclaredType() aa6d22ed> Returns the Java binding of the xml element declaration's type attribute. 
<javax.xml.bind|JAXBElement.getName() 46036b07> Returns the xml element tag name. 
<javax.xml.bind|JAXBElement.setValue(java.lang.Object) 521f93c5> Set the content model and attributes of this xml element. 
<javax.xml.bind|JAXBElement.setValue(java.lang.Object) 2cbe82b4> When this property is set to null, isNil() must by true. 
<javax.xml.bind|JAXBElement.setValue(java.lang.Object) d024ac69> Details of constraint are described at {@link #isNil()}.. 
<javax.xml.bind|JAXBElement.getValue() 2d189053> Return the content model and attribute values for this element. 
<javax.xml.bind|JAXBElement.getValue() c73bdb53> See {@link #isNil()} for a description of a property constraint when this value is null. 
<javax.xml.bind|JAXBElement.getScope() 95c84282> Returns scope of xml element declaration. 
<javax.xml.bind|JAXBElement.getScope() 1eddd7e2> @return:GlobalScope.class if this element is of global scope. 
<javax.xml.bind|JAXBElement.isNil() a2fb42ba> Returns true iff this element instance content model is nil. 
<javax.xml.bind|JAXBElement.isNil() f10c645e> This property always returns true when {@link #getValue()} is null. 
<javax.xml.bind|JAXBElement.isNil() 62f94afa> Note that the converse is not true, when this property is true, {@link #getValue()} can contain a non-null value for attribute(s). 
<javax.xml.bind|JAXBElement.isNil() 1b034177> It is valid for a nil xml element to have attribute(s).. 
<javax.xml.bind|JAXBElement.setNil(boolean) 53fe138c> Set whether this element has nil content.. 
<javax.xml.bind|JAXBElement.isGlobalScope() 1053cf91> Returns true iff this xml element declaration is global. 
<javax.xml.bind|JAXBElement.isTypeSubstituted() 432faa27> Returns true iff this xml element instance's value has a different type than xml element declaration's declared type. 
<javax.xml.bind|JAXBElement.name 76abf810> xml element tag name. 
<javax.xml.bind|JAXBElement.declaredType 35d1fc47> Java datatype binding for xml element declaration's type. 
<javax.xml.bind|JAXBElement.scope 90dadf30> Scope of xml element declaration representing this xml element instance. 
<javax.xml.bind|JAXBElement.scope 5b9205ef> Can be one of the following values: - {@link GlobalScope} for global xml element declaration. 
<javax.xml.bind|JAXBElement.scope cccbf604> - local element declaration has a scope set to the Java class representation of complex type defintion containing xml element declaration. 
<javax.xml.bind|JAXBElement.value ca944ad4> xml element value. 
<javax.xml.bind|JAXBElement.value 6120a847> Represents content model and attributes of an xml element instance. 
<javax.xml.bind|JAXBElement.nil f752fe5f> true iff the xml element instance has xsi:nil="true". 
<javax.xml.bind|JAXBElement.GlobalScope 9be1a6b8> Designates global scope for an xml element. 
<javax.xml.bind|JAXBContext 3cae3e36>  The JAXBContext class provides the client's entry point to the JAXB API. 
<javax.xml.bind|JAXBContext 97202a13> It provides an abstraction for managing the XML/Java binding information necessary to implement the JAXB binding framework operations: unmarshal, marshal and validate. 
<javax.xml.bind|JAXBContext f00bfd74> A client application normally obtains new instances of this class using one of these two styles for newInstance methods, although there are other specialized forms of the method available: {@link #newInstance(String,ClassLoader) JAXBContext.newInstance( "com.acme.foo:com.acme.bar" )} The JAXBContext instance is initialized from a list of colon separated Java package names. 
<javax.xml.bind|JAXBContext 30a30d21> Each java package contains JAXB mapped classes, schema-derived classes and/or user annotated classes. 
<javax.xml.bind|JAXBContext 96a2684e> Additionally, the java package may contain JAXB package annotations that must be processed. 
<javax.xml.bind|JAXBContext 84a3bb2b> (see JLS 3rd Edition, Section 7.4.1. 
<javax.xml.bind|JAXBContext dde3fd55> Package Annotations). 
<javax.xml.bind|JAXBContext 97f10dca> {@link #newInstance(Class...) JAXBContext.newInstance( com.acme.foo.Foo.class )} The JAXBContext instance is intialized with class(es) passed as parameter(s) and classes that are statically reachable from these class(es). 
<javax.xml.bind|JAXBContext 65f22dbf> See {@link #newInstance(Class...)} for details. 
<javax.xml.bind|JAXBContext 29d2258b> SPEC REQUIREMENT: the provider must supply an implementation class containing the following method signatures: public static JAXBContext createContext( String contextPath, ClassLoader classLoader, Map properties ) throws JAXBException public static JAXBContext createContext( Class[] classes, Map properties ) throws JAXBException The following JAXB 1.0 requirement is only required for schema to java interface/implementation binding. 
<javax.xml.bind|JAXBContext 95bbf0dc> It does not apply to JAXB annotated classes. 
<javax.xml.bind|JAXBContext 9cbdae64> JAXB Providers must generate a jaxb.properties file in each package containing schema derived classes. 
<javax.xml.bind|JAXBContext 75524fb> The property file must contain a property named javax.xml.bind.context.factory whose value is the name of the class that implements the createContext APIs. 
<javax.xml.bind|JAXBContext ee19539e> The class supplied by the provider does not have to be assignable to javax.xml.bind.JAXBContext, it simply has to provide a class that implements the createContext APIs. 
<javax.xml.bind|JAXBContext da8ed9d1> In addition, the provider must call the {@link DatatypeConverter#setDatatypeConverter(DatatypeConverterInterface) DatatypeConverter.setDatatypeConverter} api prior to any client invocations of the marshal and unmarshal methods. 
<javax.xml.bind|JAXBContext 79f4e511> This is necessary to configure the datatype converter that will be used during these operations. 
<javax.xml.bind|JAXBContext 39640078> Unmarshalling The {@link Unmarshaller} class provides the client application the ability to convert XML data into a tree of Java content objects. 
<javax.xml.bind|JAXBContext a36bba9e> The unmarshal method allows for any global XML element declared in the schema to be unmarshalled as the root of an instance document. 
<javax.xml.bind|JAXBContext ccd7f449> Additionally, the unmarshal method allows for an unrecognized root element that has an xsi:type attribute's value that references a type definition declared in the schema to be unmarshalled as the root of an instance document. 
<javax.xml.bind|JAXBContext dd475621> The JAXBContext object allows the merging of global elements and type definitions across a set of schemas (listed in the contextPath). 
<javax.xml.bind|JAXBContext 130e9813> Since each schema in the schema set can belong to distinct namespaces, the unification of schemas to an unmarshalling context should be namespace independent. 
<javax.xml.bind|JAXBContext a4816904> This means that a client application is able to unmarshal XML documents that are instances of any of the schemas listed in the contextPath. 
<javax.xml.bind|JAXBContext ea5014a> For example: JAXBContext jc = JAXBContext.newInstance( "com.acme.foo:com.acme.bar" ); Unmarshaller u = jc.createUnmarshaller(); FooObject fooObj = (FooObject)u.unmarshal( new File( "foo.xml" ) ); // ok BarObject barObj = (BarObject)u.unmarshal( new File( "bar.xml" ) ); // ok BazObject bazObj = (BazObject)u.unmarshal( new File( "baz.xml" ) ); // error, "com.acme.baz" not in contextPath The client application may also generate Java content trees explicitly rather than unmarshalling existing XML data. 
<javax.xml.bind|JAXBContext 24cfd76b> For all JAXB-annotated value classes, an application can create content using constructors. 
<javax.xml.bind|JAXBContext 2049d7c7> For schema-derived interface/implementation classes and for the creation of elements that are not bound to a JAXB-annotated class, an application needs to have access and knowledge about each of the schema derived ObjectFactory classes that exist in each of java packages contained in the contextPath. 
<javax.xml.bind|JAXBContext 58fe3cce> For each schema derived java class, there is a static factory method that produces objects of that type. 
<javax.xml.bind|JAXBContext 310b4193> For example, assume that after compiling a schema, you have a package com.acme.foo that contains a schema derived interface named PurchaseOrder. 
<javax.xml.bind|JAXBContext 175241ee> In order to create objects of that type, the client application would use the factory method like this: com.acme.foo.PurchaseOrder po = com.acme.foo.ObjectFactory.createPurchaseOrder(); Once the client application has an instance of the the schema derived object, it can use the mutator methods to set content on it. 
<javax.xml.bind|JAXBContext 5209bc1d> For more information on the generated ObjectFactory classes, see Section 4.2 Java Package of the specification. 
<javax.xml.bind|JAXBContext c3bfb190> SPEC REQUIREMENT: the provider must generate a class in each package that contains all of the necessary object factory methods for that package named ObjectFactory as well as the static newInstance( javaContentInterface ) method Marshalling The {@link Marshaller} class provides the client application the ability to convert a Java content tree back into XML data. 
<javax.xml.bind|JAXBContext ef24dfdb> There is no difference between marshalling a content tree that is created manually using the factory methods and marshalling a content tree that is the result an unmarshal operation. 
<javax.xml.bind|JAXBContext 21a96564> Clients can marshal a java content tree back to XML data to a java.io.OutputStream or a java.io.Writer. 
<javax.xml.bind|JAXBContext eca39429> The marshalling process can alternatively produce SAX2 event streams to a registered ContentHandler or produce a DOM Node object. 
<javax.xml.bind|JAXBContext ec34e915> Client applications have control over the output encoding as well as whether or not to marshal the XML data as a complete document or as a fragment. 
<javax.xml.bind|JAXBContext 92e29aca> Here is a simple example that unmarshals an XML document and then marshals it back out: JAXBContext jc = JAXBContext.newInstance( "com.acme.foo" ); // unmarshal from foo.xml Unmarshaller u = jc.createUnmarshaller(); FooObject fooObj = (FooObject)u.unmarshal( new File( "foo.xml" ) ); // marshal to System.out Marshaller m = jc.createMarshaller(); m.marshal( fooObj, System.out ); Validation Validation has been changed significantly since JAXB 1.0. 
<javax.xml.bind|JAXBContext a5f6825d> The {@link Validator} class has been deprecated and made optional. 
<javax.xml.bind|JAXBContext e5b4651d> This means that you are advised not to use this class and, in fact, it may not even be available depending on your JAXB provider. 
<javax.xml.bind|JAXBContext 4cf3f749> JAXB 1.0 client applications that rely on Validator will still work properly when deployed with the JAXB 1.0 runtime system. 
<javax.xml.bind|JAXBContext d3480651> In JAXB 2.0, the {@link Unmarshaller} has included convenince methods that expose the JAXP 1.3 {@link javax.xml.validation} framework. 
<javax.xml.bind|JAXBContext a265a844> Please refer to the {@link Unmarshaller#setSchema(javax.xml.validation.Schema)} API for more information. 
<javax.xml.bind|JAXBContext e3b5c9fe> JAXB Runtime Binding Framework Compatibility The following JAXB 1.0 restriction only applies to binding schema to interfaces/implementation classes. 
<javax.xml.bind|JAXBContext d5c8a163> Since this binding does not require a common runtime system, a JAXB client application must not attempt to mix runtime objects (JAXBContext, Marshaller, etc. 
<javax.xml.bind|JAXBContext 214746dd> ) from different providers. 
<javax.xml.bind|JAXBContext 58958c78> This does not mean that the client application isn't portable, it simply means that a client has to use a runtime system provided by the same provider that was used to compile the schema. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String) 11256061>  Obtain a new instance of a JAXBContext class. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String) d027916c> This is a convenience method for the {@link #newInstance(String,ClassLoader) newInstance} method. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String) 67c97649> It uses the context class loader of the current thread. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String) 9a06d3ee> To specify the use of a different class loader, either set it via the Thread.setContextClassLoader() api or use the {@link #newInstance(String,ClassLoader) newInstance} method. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String) 37e820ad> @throws:JAXBException if an error was encountered while creating the JAXBContext such as failure to locate either ObjectFactory.class or jaxb.index in the packages an ambiguity among global elements contained in the contextPath failure to locate a value for the context factory provider property mixing schema derived packages from different providers on the same contextPath . 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) 11256061>  Obtain a new instance of a JAXBContext class. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) 15ecc00d> The client application must supply a context path which is a list of colon (':', \u003A) separated java package names that contain schema-derived classes and/or fully qualified JAXB-annotated classes. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) d57e3853> Schema-derived code is registered with the JAXBContext by the ObjectFactory.class generated per package. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) f788c2a0> Alternatively than being listed in the context path, programmer annotated JAXB mapped classes can be listed in a jaxb.index resource file, format described below. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) 6345291e> Note that a java package can contain both schema-derived classes and user annotated JAXB classes. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) 96a2684e> Additionally, the java package may contain JAXB package annotations that must be processed. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) 84a3bb2b> (see JLS 3rd Edition, Section 7.4.1. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) dde3fd55> "Package Annotations"). 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) 18557516> Every package listed on the contextPath must meet one or both of the following conditions otherwise a JAXBException will be thrown: it must contain ObjectFactory.class it must contain jaxb.index Format for jaxb.index The file contains a newline-separated list of class names. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) aa081cdb> Space and tab characters, as well as blank lines, are ignored. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) cb825e74> The comment character is '#' (0x23); on each line all characters following the first comment character are ignored. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) 81e1a528> The file must be encoded in UTF-8. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) b8a7e38a> Classes that are reachable, as defined in {@link #newInstance(Class...)}, from the listed classes are also registered with JAXBContext. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) 79bdc996> Constraints on class name occuring in a jaxb.index file are: Must not end with ".class". 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) 150c01a7> Class names are resolved relative to package containing jaxb.index file. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) b45be558> Only classes occuring directly in package containing jaxb.index file are allowed. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) c020a6> Fully qualified class names are not allowed. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) 7f99a9d9> A qualified class name,relative to current package, is only allowed to specify a nested or inner class. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) 3f604b09> To maintain compatibility with JAXB 1.0 schema to java interface/implementation binding, enabled by schema customization , the JAXB provider will ensure that each package on the context path has a jaxb.properties file which contains a value for the javax.xml.bind.context.factory property and that all values resolve to the same provider. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) d220eb67> This requirement does not apply to JAXB annotated classes. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) 38a50483> If there are any global XML element name collisions across the various packages listed on the contextPath, a JAXBException will be thrown. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) 6f47dbaa> Mixing generated interface/impl bindings from multiple JAXB Providers in the same context path may result in a JAXBException being thrown. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) 11c459ba> @return:a new instance of a JAXBContext. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader) 37e820ad> @throws:JAXBException if an error was encountered while creating the JAXBContext such as failure to locate either ObjectFactory.class or jaxb.index in the packages an ambiguity among global elements contained in the contextPath failure to locate a value for the context factory provider property mixing schema derived packages from different providers on the same contextPath . 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader,java.util.Map) 11256061>  Obtain a new instance of a JAXBContext class. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader,java.util.Map) c3b4464c> This is mostly the same as {@link JAXBContext#newInstance(String, ClassLoader)}, but this version allows you to pass in provider-specific properties to configure the instanciation of {@link JAXBContext}. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader,java.util.Map) 5b9239ad> The interpretation of properties is up to implementations. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader,java.util.Map) 11c459ba> @return:a new instance of a JAXBContext. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.String,java.lang.ClassLoader,java.util.Map) 37e820ad> @throws:JAXBException if an error was encountered while creating the JAXBContext such as failure to locate either ObjectFactory.class or jaxb.index in the packages an ambiguity among global elements contained in the contextPath failure to locate a value for the context factory provider property mixing schema derived packages from different providers on the same contextPath . 
<javax.xml.bind|JAXBContext.newInstance(java.lang.Class[]) 11256061>  Obtain a new instance of a JAXBContext class. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.Class[]) 67f6657f> The client application must supply a list of classes that the new context object needs to recognize. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.Class[]) 12afd311> Not only the new context will recognize all the classes specified, but it will also recognize any classes that are directly/indirectly referenced statically from the specified classes. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.Class[]) aac790c2> Subclasses of referenced classes nor &#64;XmlTransient referenced classes are not registered with JAXBContext. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.Class[]) 96523c6c> For example, in the following Java code, if you do newInstance(Foo.class), the newly created {@link JAXBContext} will recognize both Foo and Bar, but not Zot or FooBar: class Foo { &#64;XmlTransient FooBar c; Bar b; } class Bar { int x; } class Zot extends Bar { int y; } class FooBar { } Therefore, a typical client application only needs to specify the top-level classes, but it needs to be careful. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.Class[]) 69ccff7c> Note that for each java package registered with JAXBContext, when the optional package annotations exist, they must be processed. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.Class[]) 84a3bb2b> (see JLS 3rd Edition, Section 7.4.1. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.Class[]) dde3fd55> "Package Annotations"). 
<javax.xml.bind|JAXBContext.newInstance(java.lang.Class[]) 11c459ba> @return:A new instance of a JAXBContext. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.Class[]) 402a4261> Always non-null valid object. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.Class[]) 1c7e7dda> @throws:JAXBException if an error was encountered while creating the JAXBContext, such as (but not limited to): No JAXB implementation was discovered Classes use JAXB annotations incorrectly Classes have colliding annotations (i.e., two classes with the same type name) The JAXB implementation was unable to locate provider-specific out-of-band information (such as additional files generated at the development time.) . 
<javax.xml.bind|JAXBContext.newInstance(java.lang.Class[]) b940058e> @throws:IllegalArgumentException if the parameter contains {@code null} (i.e., {@code newInstance(null);}). 
<javax.xml.bind|JAXBContext.newInstance(java.lang.Class[],java.util.Map) 11256061>  Obtain a new instance of a JAXBContext class. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.Class[],java.util.Map) ab8350da> An overloading of {@link JAXBContext#newInstance(Class...)} to configure 'properties' for this instantiation of {@link JAXBContext}. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.Class[],java.util.Map) 96a5dd21> The interpretation of properties is implementation specific. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.Class[],java.util.Map) 11c459ba> @return:A new instance of a JAXBContext. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.Class[],java.util.Map) 402a4261> Always non-null valid object. 
<javax.xml.bind|JAXBContext.newInstance(java.lang.Class[],java.util.Map) 1c7e7dda> @throws:JAXBException if an error was encountered while creating the JAXBContext, such as (but not limited to): No JAXB implementation was discovered Classes use JAXB annotations incorrectly Classes have colliding annotations (i.e., two classes with the same type name) The JAXB implementation was unable to locate provider-specific out-of-band information (such as additional files generated at the development time.) . 
<javax.xml.bind|JAXBContext.newInstance(java.lang.Class[],java.util.Map) b940058e> @throws:IllegalArgumentException if the parameter contains {@code null} (i.e., {@code newInstance(null);}). 
<javax.xml.bind|JAXBContext.createUnmarshaller() 2c351721> Create an Unmarshaller object that can be used to convert XML data into a java content tree. 
<javax.xml.bind|JAXBContext.createUnmarshaller() 2e074f73> @return:an Unmarshaller object. 
<javax.xml.bind|JAXBContext.createUnmarshaller() 5e197468> @throws:JAXBException if an error was encountered while creating the Unmarshaller object. 
<javax.xml.bind|JAXBContext.createMarshaller() 15a47fed> Create a Marshaller object that can be used to convert a java content tree into XML data. 
<javax.xml.bind|JAXBContext.createMarshaller() 5187adb3> @return:a Marshaller object. 
<javax.xml.bind|JAXBContext.createMarshaller() b9b6932c> @throws:JAXBException if an error was encountered while creating the Marshaller object. 
<javax.xml.bind|JAXBContext.createValidator() 2252c0ec> {@link Validator} has been made optional and deprecated in JAXB 2.0. 
<javax.xml.bind|JAXBContext.createValidator() b12050ee> Please refer to the javadoc for {@link Validator} for more detail. 
<javax.xml.bind|JAXBContext.createValidator() 27eb4a83> Create a Validator object that can be used to validate a java content tree against its source schema. 
<javax.xml.bind|JAXBContext.createValidator() 109075a7> @return:a Validator object. 
<javax.xml.bind|JAXBContext.createValidator() a3fc6560> @throws:JAXBException if an error was encountered while creating the Validator object. 
<javax.xml.bind|JAXBContext.createBinder(java.lang.Class) 2717e0a> Creates a Binder object that can be used for associative/in-place unmarshalling/marshalling. 
<javax.xml.bind|JAXBContext.createBinder(java.lang.Class) ec7a6a55> @return:always a new valid Binder object. 
<javax.xml.bind|JAXBContext.createBinder(java.lang.Class) d2a37ebb> @throws:UnsupportedOperationException if DOM API corresponding to domType is not supported by the implementation. 
<javax.xml.bind|JAXBContext.createBinder() ddd02bbc> Creates a Binder for W3C DOM. 
<javax.xml.bind|JAXBContext.createBinder() ec7a6a55> @return:always a new valid Binder object. 
<javax.xml.bind|JAXBContext.createJAXBIntrospector() bb63d44b> Creates a JAXBIntrospector object that can be used to introspect JAXB objects. 
<javax.xml.bind|JAXBContext.createJAXBIntrospector() 2b2a2359> @return:always return a non-null valid JAXBIntrospector object. 
<javax.xml.bind|JAXBContext.createJAXBIntrospector() 193c2e88> @throws:UnsupportedOperationException Calling this method on JAXB 1.0 implementations will throw an UnsupportedOperationException. 
<javax.xml.bind|JAXBContext.generateSchema(javax.xml.bind.SchemaOutputResolver) b365d264> Generates the schema documents for this context. 
<javax.xml.bind|JAXBContext.generateSchema(javax.xml.bind.SchemaOutputResolver) 3d779c18> @throws:IOException if {@link SchemaOutputResolver} throws an {@link IOException}. 
<javax.xml.bind|JAXBContext.generateSchema(javax.xml.bind.SchemaOutputResolver) 193c2e88> @throws:UnsupportedOperationException Calling this method on JAXB 1.0 implementations will throw an UnsupportedOperationException. 
<javax.xml.bind|JAXBContext.JAXB_CONTEXT_FACTORY f1690adf> The name of the property that contains the name of the class capable of creating new JAXBContext objects. 
<javax.xml.bind|Element 7067eedc> This is an element marker interface. 
<javax.xml.bind|Element 7fffb0e9> Under certain circumstances, it is necessary for the binding compiler to generate derived java content classes that implement this interface. 
<javax.xml.bind|Element 2fbbc113> In those cases, client applications must supply element instances rather than types of elements. 
<javax.xml.bind|Element d84acf5e> For more detail, see section 5.7 "Element Declaration" and 5.7.1 "Bind to Java Element Interface" of the specification. 
<javax.xml.bind|DatatypeConverterInterface 9db979b8>  The DatatypeConverterInterface is for JAXB provider use only. 
<javax.xml.bind|DatatypeConverterInterface e945e0fc> A JAXB provider must supply a class that implements this interface. 
<javax.xml.bind|DatatypeConverterInterface d86bed90> JAXB Providers are required to call the {@link DatatypeConverter#setDatatypeConverter(DatatypeConverterInterface) DatatypeConverter.setDatatypeConverter} api at some point before the first marshal or unmarshal operation (perhaps during the call to JAXBContext.newInstance). 
<javax.xml.bind|DatatypeConverterInterface dcdb6980> This step is necessary to configure the converter that should be used to perform the print and parse functionality. 
<javax.xml.bind|DatatypeConverterInterface c74fcd17> Calling this api repeatedly will have no effect - the DatatypeConverter instance passed into the first invocation is the one that will be used from then on. 
<javax.xml.bind|DatatypeConverterInterface 1e05ffa6> This interface defines the parse and print methods. 
<javax.xml.bind|DatatypeConverterInterface f4f14c94> There is one parse and print method for each XML schema datatype specified in the the default binding Table 5-1 in the JAXB specification. 
<javax.xml.bind|DatatypeConverterInterface 4cd7774> The parse and print methods defined here are invoked by the static parse and print methods defined in the {@link DatatypeConverter DatatypeConverter} class. 
<javax.xml.bind|DatatypeConverterInterface 9206a22f> A parse method for a XML schema datatype must be capable of converting any lexical representation of the XML schema datatype ( specified by the XML Schema Part2: Datatypes specification into a value in the value space of the XML schema datatype. 
<javax.xml.bind|DatatypeConverterInterface 20fe1a74> If an error is encountered during conversion, then an IllegalArgumentException or a subclass of IllegalArgumentException must be thrown by the method. 
<javax.xml.bind|DatatypeConverterInterface b811488d> A print method for a XML schema datatype can output any lexical representation that is valid with respect to the XML schema datatype. 
<javax.xml.bind|DatatypeConverterInterface 99b9ba56> The prefix xsd: is used to refer to XML schema datatypes XML Schema Part2: Datatypes specification. 
<javax.xml.bind|DatatypeConverterInterface.parseString(java.lang.String) 16d8f5ef>  Convert the string argument into a string. 
<javax.xml.bind|DatatypeConverterInterface.parseString(java.lang.String) b6a86892> @return:A string that is the same as the input string. 
<javax.xml.bind|DatatypeConverterInterface.parseInteger(java.lang.String) 2dd177c7>  Convert the string argument into a BigInteger value. 
<javax.xml.bind|DatatypeConverterInterface.parseInteger(java.lang.String) c3ea0214> @return:A BigInteger value represented by the string argument. 
<javax.xml.bind|DatatypeConverterInterface.parseInteger(java.lang.String) 5d464af8> @throws:NumberFormatException lexicalXSDInteger is not a valid string representation of a {@link java.math.BigInteger} value. 
<javax.xml.bind|DatatypeConverterInterface.parseInt(java.lang.String) 168fceaf>  Convert the string argument into an int value. 
<javax.xml.bind|DatatypeConverterInterface.parseInt(java.lang.String) 39d79632> @return:An int value represented byte the string argument. 
<javax.xml.bind|DatatypeConverterInterface.parseInt(java.lang.String) c0036441> @throws:NumberFormatException lexicalXSDInt is not a valid string representation of an int value. 
<javax.xml.bind|DatatypeConverterInterface.parseLong(java.lang.String) 72384e07>  Converts the string argument into a long value. 
<javax.xml.bind|DatatypeConverterInterface.parseLong(java.lang.String) a455a341> @return:A long value represented by the string argument. 
<javax.xml.bind|DatatypeConverterInterface.parseLong(java.lang.String) 7fe13c35> @throws:NumberFormatException lexicalXSDLong is not a valid string representation of a long value. 
<javax.xml.bind|DatatypeConverterInterface.parseShort(java.lang.String) e073cc61>  Converts the string argument into a short value. 
<javax.xml.bind|DatatypeConverterInterface.parseShort(java.lang.String) a557a513> @return:A short value represented by the string argument. 
<javax.xml.bind|DatatypeConverterInterface.parseShort(java.lang.String) 78ac6d67> @throws:NumberFormatException lexicalXSDShort is not a valid string representation of a short value. 
<javax.xml.bind|DatatypeConverterInterface.parseDecimal(java.lang.String) 5f00912d>  Converts the string argument into a BigDecimal value. 
<javax.xml.bind|DatatypeConverterInterface.parseDecimal(java.lang.String) 98694a47> @return:A BigDecimal value represented by the string argument. 
<javax.xml.bind|DatatypeConverterInterface.parseDecimal(java.lang.String) 50f4828> @throws:NumberFormatException lexicalXSDDecimal is not a valid string representation of {@link java.math.BigDecimal}. 
<javax.xml.bind|DatatypeConverterInterface.parseFloat(java.lang.String) 71e30910>  Converts the string argument into a float value. 
<javax.xml.bind|DatatypeConverterInterface.parseFloat(java.lang.String) 5cf157d8> @return:A float value represented by the string argument. 
<javax.xml.bind|DatatypeConverterInterface.parseFloat(java.lang.String) 800ce215> @throws:NumberFormatException lexicalXSDFloat is not a valid string representation of a float value. 
<javax.xml.bind|DatatypeConverterInterface.parseDouble(java.lang.String) 71c23050>  Converts the string argument into a double value. 
<javax.xml.bind|DatatypeConverterInterface.parseDouble(java.lang.String) 4f4f3898> @return:A double value represented by the string argument. 
<javax.xml.bind|DatatypeConverterInterface.parseDouble(java.lang.String) 5254ba15> @throws:NumberFormatException lexicalXSDDouble is not a valid string representation of a double value. 
<javax.xml.bind|DatatypeConverterInterface.parseBoolean(java.lang.String) 71aa9486>  Converts the string argument into a boolean value. 
<javax.xml.bind|DatatypeConverterInterface.parseBoolean(java.lang.String) 6d82b222> @return:A boolean value represented by the string argument. 
<javax.xml.bind|DatatypeConverterInterface.parseBoolean(java.lang.String) 516bec18> @throws:IllegalArgumentException if string parameter does not conform to lexical value space defined in XML Schema Part 2: Datatypes for xsd:boolean. 
<javax.xml.bind|DatatypeConverterInterface.parseByte(java.lang.String) 71b093df>  Converts the string argument into a byte value. 
<javax.xml.bind|DatatypeConverterInterface.parseByte(java.lang.String) bfff469> @return:A byte value represented by the string argument. 
<javax.xml.bind|DatatypeConverterInterface.parseByte(java.lang.String) 6d3c368> @throws:NumberFormatException lexicalXSDByte does not contain a parseable byte. 
<javax.xml.bind|DatatypeConverterInterface.parseByte(java.lang.String) 516bedb1> @throws:IllegalArgumentException if string parameter does not conform to lexical value space defined in XML Schema Part 2: Datatypes for xsd:byte. 
<javax.xml.bind|DatatypeConverterInterface.parseQName(java.lang.String,javax.xml.namespace.NamespaceContext) 727eda12>  Converts the string argument into a QName value. 
<javax.xml.bind|DatatypeConverterInterface.parseQName(java.lang.String,javax.xml.namespace.NamespaceContext) e18a1fd6> String parameter lexicalXSDQname must conform to lexical value space specifed at XML Schema Part 2:Datatypes specification:QNames. 
<javax.xml.bind|DatatypeConverterInterface.parseQName(java.lang.String,javax.xml.namespace.NamespaceContext) 959d9c16> @return:A QName value represented by the string argument. 
<javax.xml.bind|DatatypeConverterInterface.parseQName(java.lang.String,javax.xml.namespace.NamespaceContext) 238784f3> @throws:IllegalArgumentException if string parameter does not conform to XML Schema Part 2 specification or if namespace prefix of lexicalXSDQname is not bound to a URI in NamespaceContext nsc. 
<javax.xml.bind|DatatypeConverterInterface.parseDateTime(java.lang.String) e635bcd5>  Converts the string argument into a Calendar value. 
<javax.xml.bind|DatatypeConverterInterface.parseDateTime(java.lang.String) 2a0907d0> @return:A Calendar object represented by the string argument. 
<javax.xml.bind|DatatypeConverterInterface.parseDateTime(java.lang.String) dc129ed5> @throws:IllegalArgumentException if string parameter does not conform to lexical value space defined in XML Schema Part 2: Datatypes for xsd:dateTime. 
<javax.xml.bind|DatatypeConverterInterface.parseBase64Binary(java.lang.String) f4ae6dbd>  Converts the string argument into an array of bytes. 
<javax.xml.bind|DatatypeConverterInterface.parseBase64Binary(java.lang.String) b4eb2c4b> @return:An array of bytes represented by the string argument. 
<javax.xml.bind|DatatypeConverterInterface.parseBase64Binary(java.lang.String) cfe31cae> @throws:IllegalArgumentException if string parameter does not conform to lexical value space defined in XML Schema Part 2: Datatypes for xsd:base64Binary. 
<javax.xml.bind|DatatypeConverterInterface.parseHexBinary(java.lang.String) f4ae6dbd>  Converts the string argument into an array of bytes. 
<javax.xml.bind|DatatypeConverterInterface.parseHexBinary(java.lang.String) b4eb2c4b> @return:An array of bytes represented by the string argument. 
<javax.xml.bind|DatatypeConverterInterface.parseHexBinary(java.lang.String) 28e9e16f> @throws:IllegalArgumentException if string parameter does not conform to lexical value space defined in XML Schema Part 2: Datatypes for xsd:hexBinary. 
<javax.xml.bind|DatatypeConverterInterface.parseUnsignedInt(java.lang.String) 72384e07>  Converts the string argument into a long value. 
<javax.xml.bind|DatatypeConverterInterface.parseUnsignedInt(java.lang.String) a455a341> @return:A long value represented by the string argument. 
<javax.xml.bind|DatatypeConverterInterface.parseUnsignedInt(java.lang.String) 7c7c03f3> @throws:NumberFormatException if string parameter can not be parsed into a long value. 
<javax.xml.bind|DatatypeConverterInterface.parseUnsignedShort(java.lang.String) 7254add6>  Converts the string argument into an int value. 
<javax.xml.bind|DatatypeConverterInterface.parseUnsignedShort(java.lang.String) 741c8ad2> @return:An int value represented by the string argument. 
<javax.xml.bind|DatatypeConverterInterface.parseUnsignedShort(java.lang.String) 7c9863c2> @throws:NumberFormatException if string parameter can not be parsed into an int value. 
<javax.xml.bind|DatatypeConverterInterface.parseTime(java.lang.String) e635bcd5>  Converts the string argument into a Calendar value. 
<javax.xml.bind|DatatypeConverterInterface.parseTime(java.lang.String) 26299eb3> @return:A Calendar value represented by the string argument. 
<javax.xml.bind|DatatypeConverterInterface.parseTime(java.lang.String) 4cf2f945> @throws:IllegalArgumentException if string parameter does not conform to lexical value space defined in XML Schema Part 2: Datatypes for xsd:Time. 
<javax.xml.bind|DatatypeConverterInterface.parseDate(java.lang.String) e635bcd5>  Converts the string argument into a Calendar value. 
<javax.xml.bind|DatatypeConverterInterface.parseDate(java.lang.String) 26299eb3> @return:A Calendar value represented by the string argument. 
<javax.xml.bind|DatatypeConverterInterface.parseDate(java.lang.String) 4cf2f75c> @throws:IllegalArgumentException if string parameter does not conform to lexical value space defined in XML Schema Part 2: Datatypes for xsd:Date. 
<javax.xml.bind|DatatypeConverterInterface.parseAnySimpleType(java.lang.String) b6aa3b0d>  Return a string containing the lexical representation of the simple type. 
<javax.xml.bind|DatatypeConverterInterface.parseAnySimpleType(java.lang.String) 7e2672cd> @return:A string containing the lexical representation of the simple type. 
<javax.xml.bind|DatatypeConverterInterface.printString(java.lang.String) 729dd516>  Converts the string argument into a string. 
<javax.xml.bind|DatatypeConverterInterface.printString(java.lang.String) 631553a9> @return:A string containing a lexical representation of xsd:string. 
<javax.xml.bind|DatatypeConverterInterface.printInteger(java.math.BigInteger) 3f639e12>  Converts a BigInteger value into a string. 
<javax.xml.bind|DatatypeConverterInterface.printInteger(java.math.BigInteger) 32ff552> @return:A string containing a lexical representation of xsd:integer. 
<javax.xml.bind|DatatypeConverterInterface.printInteger(java.math.BigInteger) ecf0951> @throws:IllegalArgumentException val is null. 
<javax.xml.bind|DatatypeConverterInterface.printInt(int) d38a8e20>  Converts an int value into a string. 
<javax.xml.bind|DatatypeConverterInterface.printInt(int) 930cd627> @return:A string containing a lexical representation of xsd:int. 
<javax.xml.bind|DatatypeConverterInterface.printLong(long) 5c6c84cf>  Converts a long value into a string. 
<javax.xml.bind|DatatypeConverterInterface.printLong(long) ce8de6e4> @return:A string containing a lexical representation of xsd:long. 
<javax.xml.bind|DatatypeConverterInterface.printShort(short) c4fc8151>  Converts a short value into a string. 
<javax.xml.bind|DatatypeConverterInterface.printShort(short) 3320f78> @return:A string containing a lexical representation of xsd:short. 
<javax.xml.bind|DatatypeConverterInterface.printDecimal(java.math.BigDecimal) 2f1ceb85>  Converts a BigDecimal value into a string. 
<javax.xml.bind|DatatypeConverterInterface.printDecimal(java.math.BigDecimal) 32b2a7f> @return:A string containing a lexical representation of xsd:decimal. 
<javax.xml.bind|DatatypeConverterInterface.printDecimal(java.math.BigDecimal) ecf0951> @throws:IllegalArgumentException val is null. 
<javax.xml.bind|DatatypeConverterInterface.printFloat(float) 6c33fda6>  Converts a float value into a string. 
<javax.xml.bind|DatatypeConverterInterface.printFloat(float) ce8dd02d> @return:A string containing a lexical representation of xsd:float. 
<javax.xml.bind|DatatypeConverterInterface.printDouble(double) e9962e66>  Converts a double value into a string. 
<javax.xml.bind|DatatypeConverterInterface.printDouble(double) ce8dc76d> @return:A string containing a lexical representation of xsd:double. 
<javax.xml.bind|DatatypeConverterInterface.printBoolean(boolean) 93b4c170>  Converts a boolean value into a string. 
<javax.xml.bind|DatatypeConverterInterface.printBoolean(boolean) ce8dc123> @return:A string containing a lexical representation of xsd:boolean. 
<javax.xml.bind|DatatypeConverterInterface.printByte(byte) dd0a7bf7>  Converts a byte value into a string. 
<javax.xml.bind|DatatypeConverterInterface.printByte(byte) ce8dc2bc> @return:A string containing a lexical representation of xsd:byte. 
<javax.xml.bind|DatatypeConverterInterface.printQName(javax.xml.namespace.QName,javax.xml.namespace.NamespaceContext) 2ddfabea>  Converts a QName instance into a string. 
<javax.xml.bind|DatatypeConverterInterface.printQName(javax.xml.namespace.QName,javax.xml.namespace.NamespaceContext) 6ab551c8> @return:A string containing a lexical representation of QName. 
<javax.xml.bind|DatatypeConverterInterface.printQName(javax.xml.namespace.QName,javax.xml.namespace.NamespaceContext) 50a7f6c0> @throws:IllegalArgumentException if val is null or if nsc is non-null or nsc.getPrefix(nsprefixFromVal) is null. 
<javax.xml.bind|DatatypeConverterInterface.printDateTime(java.util.Calendar) f7b7f5c1>  Converts a Calendar value into a string. 
<javax.xml.bind|DatatypeConverterInterface.printDateTime(java.util.Calendar) 32b6b2a> @return:A string containing a lexical representation of xsd:dateTime. 
<javax.xml.bind|DatatypeConverterInterface.printDateTime(java.util.Calendar) 8d5e8c37> @throws:IllegalArgumentException if val is null. 
<javax.xml.bind|DatatypeConverterInterface.printBase64Binary(byte[]) 41059359>  Converts an array of bytes into a string. 
<javax.xml.bind|DatatypeConverterInterface.printBase64Binary(byte[]) ea63b683> @return:A string containing a lexical representation of xsd:base64Binary. 
<javax.xml.bind|DatatypeConverterInterface.printBase64Binary(byte[]) 8d5e8c37> @throws:IllegalArgumentException if val is null. 
<javax.xml.bind|DatatypeConverterInterface.printHexBinary(byte[]) 41059359>  Converts an array of bytes into a string. 
<javax.xml.bind|DatatypeConverterInterface.printHexBinary(byte[]) ed00ec84> @return:A string containing a lexical representation of xsd:hexBinary. 
<javax.xml.bind|DatatypeConverterInterface.printHexBinary(byte[]) 8d5e8c37> @throws:IllegalArgumentException if val is null. 
<javax.xml.bind|DatatypeConverterInterface.printUnsignedInt(long) 5c6c84cf>  Converts a long value into a string. 
<javax.xml.bind|DatatypeConverterInterface.printUnsignedInt(long) e8400c7d> @return:A string containing a lexical representation of xsd:unsignedInt. 
<javax.xml.bind|DatatypeConverterInterface.printUnsignedShort(int) d38a8e20>  Converts an int value into a string. 
<javax.xml.bind|DatatypeConverterInterface.printUnsignedShort(int) d871084e> @return:A string containing a lexical representation of xsd:unsignedShort. 
<javax.xml.bind|DatatypeConverterInterface.printTime(java.util.Calendar) f7b7f5c1>  Converts a Calendar value into a string. 
<javax.xml.bind|DatatypeConverterInterface.printTime(java.util.Calendar) 930cd6da> @return:A string containing a lexical representation of xsd:time. 
<javax.xml.bind|DatatypeConverterInterface.printTime(java.util.Calendar) 8d5e8c37> @throws:IllegalArgumentException if val is null. 
<javax.xml.bind|DatatypeConverterInterface.printDate(java.util.Calendar) f7b7f5c1>  Converts a Calendar value into a string. 
<javax.xml.bind|DatatypeConverterInterface.printDate(java.util.Calendar) 930cd4f1> @return:A string containing a lexical representation of xsd:date. 
<javax.xml.bind|DatatypeConverterInterface.printDate(java.util.Calendar) 8d5e8c37> @throws:IllegalArgumentException if val is null. 
<javax.xml.bind|DatatypeConverterInterface.printAnySimpleType(java.lang.String) fa3a786a>  Converts a string value into a string. 
<javax.xml.bind|DatatypeConverterInterface.printAnySimpleType(java.lang.String) c1741d49> @return:A string containing a lexical representation of xsd:AnySimpleType. 
<javax.xml.bind|DatatypeConverter e7e6e0f>  The javaType binding declaration can be used to customize the binding of an XML schema datatype to a Java datatype. 
<javax.xml.bind|DatatypeConverter b2f00889> Customizations can involve writing a parse and print method for parsing and printing lexical representations of a XML schema datatype respectively. 
<javax.xml.bind|DatatypeConverter 548449cb> However, writing parse and print methods requires knowledge of the lexical representations ( XML Schema Part2: Datatypes specification ) and hence may be difficult to write. 
<javax.xml.bind|DatatypeConverter 301b39cc> This class makes it easier to write parse and print methods. 
<javax.xml.bind|DatatypeConverter ead3bc2e> It defines static parse and print methods that provide access to a JAXB provider's implementation of parse and print methods. 
<javax.xml.bind|DatatypeConverter 70b4e483> These methods are invoked by custom parse and print methods. 
<javax.xml.bind|DatatypeConverter f85e058c> For example, the binding of xsd:dateTime to a long can be customized using parse and print methods as follows: // Customized parse method public long myParseCal( String dateTimeString ) { java.util.Calendar cal = DatatypeConverter.parseDateTime(dateTimeString); long longval = convert_calendar_to_long(cal); //application specific return longval; } // Customized print method public String myPrintCal( Long longval ) { java.util.Calendar cal = convert_long_to_calendar(longval) ; //application specific String dateTimeString = DatatypeConverter.printDateTime(cal); return dateTimeString; } There is a static parse and print method corresponding to each parse and print method respectively in the {@link DatatypeConverterInterface DatatypeConverterInterface}. 
<javax.xml.bind|DatatypeConverter ff4cc14> The static methods defined in the class can also be used to specify a parse or a print method in a javaType binding declaration. 
<javax.xml.bind|DatatypeConverter 6a5cb738> JAXB Providers are required to call the {@link #setDatatypeConverter(DatatypeConverterInterface) setDatatypeConverter} api at some point before the first marshal or unmarshal operation (perhaps during the call to JAXBContext.newInstance). 
<javax.xml.bind|DatatypeConverter dcdb6980> This step is necessary to configure the converter that should be used to perform the print and parse functionality. 
<javax.xml.bind|DatatypeConverter b811488d> A print method for a XML schema datatype can output any lexical representation that is valid with respect to the XML schema datatype. 
<javax.xml.bind|DatatypeConverter 20fe1a74> If an error is encountered during conversion, then an IllegalArgumentException, or a subclass of IllegalArgumentException must be thrown by the method. 
<javax.xml.bind|DatatypeConverter.setDatatypeConverter(javax.xml.bind.DatatypeConverterInterface) eab0f3f3> This method is for JAXB provider use only. 
<javax.xml.bind|DatatypeConverter.setDatatypeConverter(javax.xml.bind.DatatypeConverterInterface) a37bdc3e> JAXB Providers are required to call this method at some point before allowing any of the JAXB client marshal or unmarshal operations to occur. 
<javax.xml.bind|DatatypeConverter.setDatatypeConverter(javax.xml.bind.DatatypeConverterInterface) 2518076d> This is necessary to configure the datatype converter that should be used to perform the print and parse conversions. 
<javax.xml.bind|DatatypeConverter.setDatatypeConverter(javax.xml.bind.DatatypeConverterInterface) dccba81e> Calling this api repeatedly will have no effect - the DatatypeConverterInterface instance passed into the first invocation is the one that will be used from then on. 
<javax.xml.bind|DatatypeConverter.setDatatypeConverter(javax.xml.bind.DatatypeConverterInterface) 9285236a> @throws:IllegalArgumentException if the parameter is null. 
<javax.xml.bind|DatatypeConverter.parseString(java.lang.String) 3bdd2d53>  Convert the lexical XSD string argument into a String value. 
<javax.xml.bind|DatatypeConverter.parseString(java.lang.String) 5af9c59c> @return:A String value represented by the string argument. 
<javax.xml.bind|DatatypeConverter.parseInteger(java.lang.String) 2dd177c7>  Convert the string argument into a BigInteger value. 
<javax.xml.bind|DatatypeConverter.parseInteger(java.lang.String) c3ea0214> @return:A BigInteger value represented by the string argument. 
<javax.xml.bind|DatatypeConverter.parseInteger(java.lang.String) 5d464af8> @throws:NumberFormatException lexicalXSDInteger is not a valid string representation of a {@link java.math.BigInteger} value. 
<javax.xml.bind|DatatypeConverter.parseInt(java.lang.String) 168fceaf>  Convert the string argument into an int value. 
<javax.xml.bind|DatatypeConverter.parseInt(java.lang.String) 8c777e44> @return:A int value represented by the string argument. 
<javax.xml.bind|DatatypeConverter.parseInt(java.lang.String) c0036441> @throws:NumberFormatException lexicalXSDInt is not a valid string representation of an int value. 
<javax.xml.bind|DatatypeConverter.parseLong(java.lang.String) 72384e07>  Converts the string argument into a long value. 
<javax.xml.bind|DatatypeConverter.parseLong(java.lang.String) a455a341> @return:A long value represented by the string argument. 
<javax.xml.bind|DatatypeConverter.parseLong(java.lang.String) 7fe13c35> @throws:NumberFormatException lexicalXSDLong is not a valid string representation of a long value. 
<javax.xml.bind|DatatypeConverter.parseShort(java.lang.String) e073cc61>  Converts the string argument into a short value. 
<javax.xml.bind|DatatypeConverter.parseShort(java.lang.String) a557a513> @return:A short value represented by the string argument. 
<javax.xml.bind|DatatypeConverter.parseShort(java.lang.String) 78ac6d67> @throws:NumberFormatException lexicalXSDShort is not a valid string representation of a short value. 
<javax.xml.bind|DatatypeConverter.parseDecimal(java.lang.String) 5f00912d>  Converts the string argument into a BigDecimal value. 
<javax.xml.bind|DatatypeConverter.parseDecimal(java.lang.String) 98694a47> @return:A BigDecimal value represented by the string argument. 
<javax.xml.bind|DatatypeConverter.parseDecimal(java.lang.String) 50f4828> @throws:NumberFormatException lexicalXSDDecimal is not a valid string representation of {@link java.math.BigDecimal}. 
<javax.xml.bind|DatatypeConverter.parseFloat(java.lang.String) 71e30910>  Converts the string argument into a float value. 
<javax.xml.bind|DatatypeConverter.parseFloat(java.lang.String) 5cf157d8> @return:A float value represented by the string argument. 
<javax.xml.bind|DatatypeConverter.parseFloat(java.lang.String) 800ce215> @throws:NumberFormatException lexicalXSDFloat is not a valid string representation of a float value. 
<javax.xml.bind|DatatypeConverter.parseDouble(java.lang.String) 71c23050>  Converts the string argument into a double value. 
<javax.xml.bind|DatatypeConverter.parseDouble(java.lang.String) 4f4f3898> @return:A double value represented by the string argument. 
<javax.xml.bind|DatatypeConverter.parseDouble(java.lang.String) 5254ba15> @throws:NumberFormatException lexicalXSDDouble is not a valid string representation of a double value. 
<javax.xml.bind|DatatypeConverter.parseBoolean(java.lang.String) 71aa9486>  Converts the string argument into a boolean value. 
<javax.xml.bind|DatatypeConverter.parseBoolean(java.lang.String) 6d82b222> @return:A boolean value represented by the string argument. 
<javax.xml.bind|DatatypeConverter.parseBoolean(java.lang.String) 516bec18> @throws:IllegalArgumentException if string parameter does not conform to lexical value space defined in XML Schema Part 2: Datatypes for xsd:boolean. 
<javax.xml.bind|DatatypeConverter.parseByte(java.lang.String) 71b093df>  Converts the string argument into a byte value. 
<javax.xml.bind|DatatypeConverter.parseByte(java.lang.String) bfff469> @return:A byte value represented by the string argument. 
<javax.xml.bind|DatatypeConverter.parseByte(java.lang.String) 516bedb1> @throws:IllegalArgumentException if string parameter does not conform to lexical value space defined in XML Schema Part 2: Datatypes for xsd:byte. 
<javax.xml.bind|DatatypeConverter.parseQName(java.lang.String,javax.xml.namespace.NamespaceContext) 71b093df>  Converts the string argument into a byte value. 
<javax.xml.bind|DatatypeConverter.parseQName(java.lang.String,javax.xml.namespace.NamespaceContext) e18a1fd6> String parameter lexicalXSDQname must conform to lexical value space specifed at XML Schema Part 2:Datatypes specification:QNames. 
<javax.xml.bind|DatatypeConverter.parseQName(java.lang.String,javax.xml.namespace.NamespaceContext) 959d9c16> @return:A QName value represented by the string argument. 
<javax.xml.bind|DatatypeConverter.parseQName(java.lang.String,javax.xml.namespace.NamespaceContext) 238784f3> @throws:IllegalArgumentException if string parameter does not conform to XML Schema Part 2 specification or if namespace prefix of lexicalXSDQname is not bound to a URI in NamespaceContext nsc. 
<javax.xml.bind|DatatypeConverter.parseDateTime(java.lang.String) e635bcd5>  Converts the string argument into a Calendar value. 
<javax.xml.bind|DatatypeConverter.parseDateTime(java.lang.String) 2a0907d0> @return:A Calendar object represented by the string argument. 
<javax.xml.bind|DatatypeConverter.parseDateTime(java.lang.String) dc129ed5> @throws:IllegalArgumentException if string parameter does not conform to lexical value space defined in XML Schema Part 2: Datatypes for xsd:dateTime. 
<javax.xml.bind|DatatypeConverter.parseBase64Binary(java.lang.String) f4ae6dbd>  Converts the string argument into an array of bytes. 
<javax.xml.bind|DatatypeConverter.parseBase64Binary(java.lang.String) b4eb2c4b> @return:An array of bytes represented by the string argument. 
<javax.xml.bind|DatatypeConverter.parseBase64Binary(java.lang.String) cfe31cae> @throws:IllegalArgumentException if string parameter does not conform to lexical value space defined in XML Schema Part 2: Datatypes for xsd:base64Binary. 
<javax.xml.bind|DatatypeConverter.parseHexBinary(java.lang.String) f4ae6dbd>  Converts the string argument into an array of bytes. 
<javax.xml.bind|DatatypeConverter.parseHexBinary(java.lang.String) b4eb2c4b> @return:An array of bytes represented by the string argument. 
<javax.xml.bind|DatatypeConverter.parseHexBinary(java.lang.String) 28e9e16f> @throws:IllegalArgumentException if string parameter does not conform to lexical value space defined in XML Schema Part 2: Datatypes for xsd:hexBinary. 
<javax.xml.bind|DatatypeConverter.parseUnsignedInt(java.lang.String) 72384e07>  Converts the string argument into a long value. 
<javax.xml.bind|DatatypeConverter.parseUnsignedInt(java.lang.String) a455a341> @return:A long value represented by the string argument. 
<javax.xml.bind|DatatypeConverter.parseUnsignedInt(java.lang.String) 7c7c03f3> @throws:NumberFormatException if string parameter can not be parsed into a long value. 
<javax.xml.bind|DatatypeConverter.parseUnsignedShort(java.lang.String) 7254add6>  Converts the string argument into an int value. 
<javax.xml.bind|DatatypeConverter.parseUnsignedShort(java.lang.String) 741c8ad2> @return:An int value represented by the string argument. 
<javax.xml.bind|DatatypeConverter.parseUnsignedShort(java.lang.String) 7c9863c2> @throws:NumberFormatException if string parameter can not be parsed into an int value. 
<javax.xml.bind|DatatypeConverter.parseTime(java.lang.String) e635bcd5>  Converts the string argument into a Calendar value. 
<javax.xml.bind|DatatypeConverter.parseTime(java.lang.String) 26299eb3> @return:A Calendar value represented by the string argument. 
<javax.xml.bind|DatatypeConverter.parseTime(java.lang.String) 4cf2f945> @throws:IllegalArgumentException if string parameter does not conform to lexical value space defined in XML Schema Part 2: Datatypes for xsd:Time. 
<javax.xml.bind|DatatypeConverter.parseDate(java.lang.String) e635bcd5>  Converts the string argument into a Calendar value. 
<javax.xml.bind|DatatypeConverter.parseDate(java.lang.String) 26299eb3> @return:A Calendar value represented by the string argument. 
<javax.xml.bind|DatatypeConverter.parseDate(java.lang.String) 4cf2f75c> @throws:IllegalArgumentException if string parameter does not conform to lexical value space defined in XML Schema Part 2: Datatypes for xsd:Date. 
<javax.xml.bind|DatatypeConverter.parseAnySimpleType(java.lang.String) b6aa3b0d>  Return a string containing the lexical representation of the simple type. 
<javax.xml.bind|DatatypeConverter.parseAnySimpleType(java.lang.String) 7e2672cd> @return:A string containing the lexical representation of the simple type. 
<javax.xml.bind|DatatypeConverter.printString(java.lang.String) 729dd516>  Converts the string argument into a string. 
<javax.xml.bind|DatatypeConverter.printString(java.lang.String) 631553a9> @return:A string containing a lexical representation of xsd:string. 
<javax.xml.bind|DatatypeConverter.printInteger(java.math.BigInteger) 3f639e12>  Converts a BigInteger value into a string. 
<javax.xml.bind|DatatypeConverter.printInteger(java.math.BigInteger) 32ff552> @return:A string containing a lexical representation of xsd:integer. 
<javax.xml.bind|DatatypeConverter.printInteger(java.math.BigInteger) ecf0951> @throws:IllegalArgumentException val is null. 
<javax.xml.bind|DatatypeConverter.printInt(int) d38a8e20>  Converts an int value into a string. 
<javax.xml.bind|DatatypeConverter.printInt(int) 930cd627> @return:A string containing a lexical representation of xsd:int. 
<javax.xml.bind|DatatypeConverter.printLong(long) 5c6c84cf>  Converts A long value into a string. 
<javax.xml.bind|DatatypeConverter.printLong(long) ce8de6e4> @return:A string containing a lexical representation of xsd:long. 
<javax.xml.bind|DatatypeConverter.printShort(short) c4fc8151>  Converts a short value into a string. 
<javax.xml.bind|DatatypeConverter.printShort(short) 3320f78> @return:A string containing a lexical representation of xsd:short. 
<javax.xml.bind|DatatypeConverter.printDecimal(java.math.BigDecimal) 2f1ceb85>  Converts a BigDecimal value into a string. 
<javax.xml.bind|DatatypeConverter.printDecimal(java.math.BigDecimal) 32b2a7f> @return:A string containing a lexical representation of xsd:decimal. 
<javax.xml.bind|DatatypeConverter.printDecimal(java.math.BigDecimal) ecf0951> @throws:IllegalArgumentException val is null. 
<javax.xml.bind|DatatypeConverter.printFloat(float) 6c33fda6>  Converts a float value into a string. 
<javax.xml.bind|DatatypeConverter.printFloat(float) ce8dd02d> @return:A string containing a lexical representation of xsd:float. 
<javax.xml.bind|DatatypeConverter.printDouble(double) e9962e66>  Converts a double value into a string. 
<javax.xml.bind|DatatypeConverter.printDouble(double) ce8dc76d> @return:A string containing a lexical representation of xsd:double. 
<javax.xml.bind|DatatypeConverter.printBoolean(boolean) 93b4c170>  Converts a boolean value into a string. 
<javax.xml.bind|DatatypeConverter.printBoolean(boolean) ce8dc123> @return:A string containing a lexical representation of xsd:boolean. 
<javax.xml.bind|DatatypeConverter.printByte(byte) dd0a7bf7>  Converts a byte value into a string. 
<javax.xml.bind|DatatypeConverter.printByte(byte) ce8dc2bc> @return:A string containing a lexical representation of xsd:byte. 
<javax.xml.bind|DatatypeConverter.printQName(javax.xml.namespace.QName,javax.xml.namespace.NamespaceContext) 2ddfabea>  Converts a QName instance into a string. 
<javax.xml.bind|DatatypeConverter.printQName(javax.xml.namespace.QName,javax.xml.namespace.NamespaceContext) 6ab551c8> @return:A string containing a lexical representation of QName. 
<javax.xml.bind|DatatypeConverter.printQName(javax.xml.namespace.QName,javax.xml.namespace.NamespaceContext) 50a7f6c0> @throws:IllegalArgumentException if val is null or if nsc is non-null or nsc.getPrefix(nsprefixFromVal) is null. 
<javax.xml.bind|DatatypeConverter.printDateTime(java.util.Calendar) f7b7f5c1>  Converts a Calendar value into a string. 
<javax.xml.bind|DatatypeConverter.printDateTime(java.util.Calendar) 32b6b2a> @return:A string containing a lexical representation of xsd:dateTime. 
<javax.xml.bind|DatatypeConverter.printDateTime(java.util.Calendar) 8d5e8c37> @throws:IllegalArgumentException if val is null. 
<javax.xml.bind|DatatypeConverter.printBase64Binary(byte[]) 41059359>  Converts an array of bytes into a string. 
<javax.xml.bind|DatatypeConverter.printBase64Binary(byte[]) ea63b683> @return:A string containing a lexical representation of xsd:base64Binary. 
<javax.xml.bind|DatatypeConverter.printBase64Binary(byte[]) 8d5e8c37> @throws:IllegalArgumentException if val is null. 
<javax.xml.bind|DatatypeConverter.printHexBinary(byte[]) 41059359>  Converts an array of bytes into a string. 
<javax.xml.bind|DatatypeConverter.printHexBinary(byte[]) ed00ec84> @return:A string containing a lexical representation of xsd:hexBinary. 
<javax.xml.bind|DatatypeConverter.printHexBinary(byte[]) 8d5e8c37> @throws:IllegalArgumentException if val is null. 
<javax.xml.bind|DatatypeConverter.printUnsignedInt(long) 5c6c84cf>  Converts a long value into a string. 
<javax.xml.bind|DatatypeConverter.printUnsignedInt(long) e8400c7d> @return:A string containing a lexical representation of xsd:unsignedInt. 
<javax.xml.bind|DatatypeConverter.printUnsignedShort(int) d38a8e20>  Converts an int value into a string. 
<javax.xml.bind|DatatypeConverter.printUnsignedShort(int) d871084e> @return:A string containing a lexical representation of xsd:unsignedShort. 
<javax.xml.bind|DatatypeConverter.printTime(java.util.Calendar) f7b7f5c1>  Converts a Calendar value into a string. 
<javax.xml.bind|DatatypeConverter.printTime(java.util.Calendar) 930cd6da> @return:A string containing a lexical representation of xsd:time. 
<javax.xml.bind|DatatypeConverter.printTime(java.util.Calendar) 8d5e8c37> @throws:IllegalArgumentException if val is null. 
<javax.xml.bind|DatatypeConverter.printDate(java.util.Calendar) f7b7f5c1>  Converts a Calendar value into a string. 
<javax.xml.bind|DatatypeConverter.printDate(java.util.Calendar) 930cd4f1> @return:A string containing a lexical representation of xsd:date. 
<javax.xml.bind|DatatypeConverter.printDate(java.util.Calendar) 8d5e8c37> @throws:IllegalArgumentException if val is null. 
<javax.xml.bind|DatatypeConverter.printAnySimpleType(java.lang.String) fa3a786a>  Converts a string value into a string. 
<javax.xml.bind|DatatypeConverter.printAnySimpleType(java.lang.String) c1741d49> @return:A string containing a lexical representation of xsd:AnySimpleType. 
<javax.xml.bind|Binder c1a84a4a> Enable synchronization between XML infoset nodes and JAXB objects representing same XML document. 
<javax.xml.bind|Binder df32158c> An instance of this class maintains the association between XML nodes of an infoset preserving view and a JAXB representation of an XML document. 
<javax.xml.bind|Binder 345f30ec> Navigation between the two views is provided by the methods {@link #getXMLNode(Object)} and {@link #getJAXBNode(Object)}. 
<javax.xml.bind|Binder 590a16bd> Modifications can be made to either the infoset preserving view or the JAXB representation of the document while the other view remains unmodified. 
<javax.xml.bind|Binder 5eebac0f> The binder is able to synchronize the changes made in the modified view back into the other view using the appropriate Binder update methods, {@link #updateXML(Object, Object)} or {@link #updateJAXB(Object)}. 
<javax.xml.bind|Binder ec92df91> A typical usage scenario is the following: load XML document into an XML infoset representation {@link #unmarshal(Object)} XML infoset view to JAXB view. 
<javax.xml.bind|Binder 4743520d> (Note to conserve resources, it is possible to only unmarshal a subtree of the XML infoset view to the JAXB view.) 
<javax.xml.bind|Binder 45451a5f>  application access/updates JAXB view of XML document. 
<javax.xml.bind|Binder 78d19290> {@link #updateXML(Object)} synchronizes modifications to JAXB view back into the XML infoset view. 
<javax.xml.bind|Binder ca32c93e> Update operation preserves as much of original XML infoset as possible (i.e. comments, PI, ...) A Binder instance is created using the factory method {@link JAXBContext#createBinder()} or {@link JAXBContext#createBinder(Class)}. 
<javax.xml.bind|Binder 9f9d7a86> The template parameter, XmlNode, is the root interface/class for the XML infoset preserving representation. 
<javax.xml.bind|Binder b2794ea3> A Binder implementation is required to minimally support an XmlNode value of org.w3c.dom.Node.class. 
<javax.xml.bind|Binder bf00b5e4> A Binder implementation can support alternative XML infoset preserving representations. 
<javax.xml.bind|Binder.unmarshal(java.lang.Object) 447acb44> Unmarshal XML infoset view to a JAXB object tree. 
<javax.xml.bind|Binder.unmarshal(java.lang.Object) d79890c0> This method is similar to {@link Unmarshaller#unmarshal(Node)} with the addition of maintaining the association between XML nodes and the produced JAXB objects, enabling future update operations, {@link #updateXML(Object, Object)} or {@link #updateJAXB(Object)}. 
<javax.xml.bind|Binder.unmarshal(java.lang.Object) ebb95aba> When {@link #getSchema()} is non-null, xmlNode and its descendants is validated during this operation. 
<javax.xml.bind|Binder.unmarshal(java.lang.Object) 18e32986> This method throws {@link UnmarshalException} when the Binder's {@link JAXBContext} does not have a mapping for the XML element name or the type, specifiable via @xsi:type, of xmlNode to a JAXB mapped class. 
<javax.xml.bind|Binder.unmarshal(java.lang.Object) 44b40edc> The method {@link #unmarshal(Object, Class)} enables an application to specify the JAXB mapped class that the xmlNode should be mapped to. 
<javax.xml.bind|Binder.unmarshal(java.lang.Object) 71b40ed3> @return:the newly created root object of the JAXB object tree. 
<javax.xml.bind|Binder.unmarshal(java.lang.Object) 48139f3e> @throws:JAXBException If any unexpected errors occur while unmarshalling. 
<javax.xml.bind|Binder.unmarshal(java.lang.Object) 2cba82ff> @throws:UnmarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Binder is unable to perform the XML to Java binding. 
<javax.xml.bind|Binder.unmarshal(java.lang.Object) 6678a0f4> @throws:IllegalArgumentException If the node parameter is null. 
<javax.xml.bind|Binder.unmarshal(java.lang.Object,java.lang.Class) 2ed95f64> Unmarshal XML root element by provided declaredType to a JAXB object tree. 
<javax.xml.bind|Binder.unmarshal(java.lang.Object,java.lang.Class) 15aa8a87> Implements Unmarshal by Declared Type This method is similar to {@link Unmarshaller#unmarshal(Node, Class)} with the addition of maintaining the association between XML nodes and the produced JAXB objects, enabling future update operations, {@link #updateXML(Object, Object)} or {@link #updateJAXB(Object)}. 
<javax.xml.bind|Binder.unmarshal(java.lang.Object,java.lang.Class) ebb95aba> When {@link #getSchema()} is non-null, xmlNode and its descendants is validated during this operation. 
<javax.xml.bind|Binder.unmarshal(java.lang.Object,java.lang.Class) af43a800> @return:JAXB Element representation of node. 
<javax.xml.bind|Binder.unmarshal(java.lang.Object,java.lang.Class) 48139f3e> @throws:JAXBException If any unexpected errors occur while unmarshalling. 
<javax.xml.bind|Binder.unmarshal(java.lang.Object,java.lang.Class) 2cba82ff> @throws:UnmarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Binder is unable to perform the XML to Java binding. 
<javax.xml.bind|Binder.unmarshal(java.lang.Object,java.lang.Class) fea9026f> @throws:IllegalArgumentException If any of the input parameters are null. 
<javax.xml.bind|Binder.marshal(java.lang.Object,java.lang.Object) 8dee5ee1> Marshal a JAXB object tree to a new XML document. 
<javax.xml.bind|Binder.marshal(java.lang.Object,java.lang.Object) e2140b76> This method is similar to {@link Marshaller#marshal(Object, Node)} with the addition of maintaining the association between JAXB objects and the produced XML nodes, enabling future update operations such as {@link #updateXML(Object, Object)} or {@link #updateJAXB(Object)}. 
<javax.xml.bind|Binder.marshal(java.lang.Object,java.lang.Object) 2e6dc6b1> When {@link #getSchema()} is non-null, the marshalled xml content is validated during this operation. 
<javax.xml.bind|Binder.marshal(java.lang.Object,java.lang.Object) c9d34777> @throws:JAXBException If any unexpected problem occurs during the marshalling. 
<javax.xml.bind|Binder.marshal(java.lang.Object,java.lang.Object) 4b304689> @throws:MarshalException If the {@link ValidationEventHandler ValidationEventHandler} returns false from its handleEvent method or the Binder is unable to marshal jaxbObject (or any object reachable from jaxbObject). 
<javax.xml.bind|Binder.marshal(java.lang.Object,java.lang.Object) e55c17d2> @throws:IllegalArgumentException If any of the method parameters are null. 
<javax.xml.bind|Binder.getXMLNode(java.lang.Object) f49cf9e> Gets the XML element associated with the given JAXB object. 
<javax.xml.bind|Binder.getXMLNode(java.lang.Object) 1d8b2b03> Once a JAXB object tree is associated with an XML fragment, this method enables navigation between the two trees. 
<javax.xml.bind|Binder.getXMLNode(java.lang.Object) 4562337d> An association between an XML element and a JAXB object is established by the bind methods and the update methods. 
<javax.xml.bind|Binder.getXMLNode(java.lang.Object) f683e3dd> Note that this association is partial; not all XML elements have associated JAXB objects, and not all JAXB objects have associated XML elements. 
<javax.xml.bind|Binder.getXMLNode(java.lang.Object) f9f9318b> @return:null if the specified JAXB object is not known to this {@link Binder}, or if it is not associated with an XML element. 
<javax.xml.bind|Binder.getXMLNode(java.lang.Object) e2e420f1> @throws:IllegalArgumentException If the jaxbObject parameter is null. 
<javax.xml.bind|Binder.getJAXBNode(java.lang.Object) 2b4e821e> Gets the JAXB object associated with the given XML element. 
<javax.xml.bind|Binder.getJAXBNode(java.lang.Object) 1d8b2b03> Once a JAXB object tree is associated with an XML fragment, this method enables navigation between the two trees. 
<javax.xml.bind|Binder.getJAXBNode(java.lang.Object) 78c75229> An association between an XML element and a JAXB object is established by the unmarshal, marshal and update methods. 
<javax.xml.bind|Binder.getJAXBNode(java.lang.Object) f683e3dd> Note that this association is partial; not all XML elements have associated JAXB objects, and not all JAXB objects have associated XML elements. 
<javax.xml.bind|Binder.getJAXBNode(java.lang.Object) 8c72f012> @return:null if the specified XML node is not known to this {@link Binder}, or if it is not associated with a JAXB object. 
<javax.xml.bind|Binder.getJAXBNode(java.lang.Object) 6678a0f4> @throws:IllegalArgumentException If the node parameter is null. 
<javax.xml.bind|Binder.updateXML(java.lang.Object) 39033d15> Takes an JAXB object and updates its associated XML node and its descendants. 
<javax.xml.bind|Binder.updateXML(java.lang.Object) 6774e72> This is a convenience method of: updateXML( jaxbObject, getXMLNode(jaxbObject)); . 
<javax.xml.bind|Binder.updateXML(java.lang.Object) 83c2d117> @throws:JAXBException If any unexpected problem occurs updating corresponding XML content. 
<javax.xml.bind|Binder.updateXML(java.lang.Object) e2e420f1> @throws:IllegalArgumentException If the jaxbObject parameter is null. 
<javax.xml.bind|Binder.updateXML(java.lang.Object,java.lang.Object) e4113a82> Changes in JAXB object tree are updated in its associated XML parse tree. 
<javax.xml.bind|Binder.updateXML(java.lang.Object,java.lang.Object) ddd2c71d> This operation can be thought of as an "in-place" marshalling. 
<javax.xml.bind|Binder.updateXML(java.lang.Object,java.lang.Object) c39d1621> The difference is that instead of creating a whole new XML tree, this operation updates an existing tree while trying to preserve the XML as much as possible. 
<javax.xml.bind|Binder.updateXML(java.lang.Object,java.lang.Object) 765107ea> For example, unknown elements/attributes in XML that were not bound to JAXB will be left untouched (whereas a marshalling operation would create a new tree that doesn't contain any of those.) As a side-effect, this operation updates the association between XML nodes and JAXB objects. 
<javax.xml.bind|Binder.updateXML(java.lang.Object,java.lang.Object) 30d8c01e> @return:Returns the updated XML node. 
<javax.xml.bind|Binder.updateXML(java.lang.Object,java.lang.Object) cb50ccd9> Typically, this is the same node you passed in as xmlNode, but it maybe a different object, for example when the tag name of the object has changed. 
<javax.xml.bind|Binder.updateXML(java.lang.Object,java.lang.Object) 83c2d117> @throws:JAXBException If any unexpected problem occurs updating corresponding XML content. 
<javax.xml.bind|Binder.updateXML(java.lang.Object,java.lang.Object) fea9026f> @throws:IllegalArgumentException If any of the input parameters are null. 
<javax.xml.bind|Binder.updateJAXB(java.lang.Object) aaf30c95> Takes an XML node and updates its associated JAXB object and its descendants. 
<javax.xml.bind|Binder.updateJAXB(java.lang.Object) 470b5a77> This operation can be thought of as an "in-place" unmarshalling. 
<javax.xml.bind|Binder.updateJAXB(java.lang.Object) 80c840d7> The difference is that instead of creating a whole new JAXB tree, this operation updates an existing tree, reusing as much JAXB objects as possible. 
<javax.xml.bind|Binder.updateJAXB(java.lang.Object) a1bbeee0> As a side-effect, this operation updates the association between XML nodes and JAXB objects. 
<javax.xml.bind|Binder.updateJAXB(java.lang.Object) 8b45055e> @return:Returns the updated JAXB object. 
<javax.xml.bind|Binder.updateJAXB(java.lang.Object) ba5f736f> Typically, this is the same object that was returned from earlier {@link #marshal(Object,Object)} or {@link #updateJAXB(Object)} method invocation, but it maybe a different object, for example when the name of the XML element has changed. 
<javax.xml.bind|Binder.updateJAXB(java.lang.Object) 797e2483> @throws:JAXBException If any unexpected problem occurs updating corresponding JAXB mapped content. 
<javax.xml.bind|Binder.updateJAXB(java.lang.Object) 44032e68> @throws:IllegalArgumentException If node parameter is null. 
<javax.xml.bind|Binder.setSchema(javax.xml.validation.Schema) 3b789a9a> Specifies whether marshal, unmarshal and update methods performs validation on their XML content. 
<javax.xml.bind|Binder.getSchema() 746ce2ba> Gets the last {@link Schema} object (including null) set by the {@link #setSchema(Schema)} method. 
<javax.xml.bind|Binder.getSchema() 43d38723> @return:the Schema object for validation or null if not present. 
<javax.xml.bind|Binder.setEventHandler(javax.xml.bind.ValidationEventHandler) 126e3720> Allow an application to register a ValidationEventHandler. 
<javax.xml.bind|Binder.setEventHandler(javax.xml.bind.ValidationEventHandler) b1e4e9a2> The ValidationEventHandler will be called by the JAXB Provider if any validation errors are encountered during calls to any of the Binder unmarshal, marshal and update methods. 
<javax.xml.bind|Binder.setEventHandler(javax.xml.bind.ValidationEventHandler) 5b325a9f> Calling this method with a null parameter will cause the Binder to revert back to the default default event handler. 
<javax.xml.bind|Binder.setEventHandler(javax.xml.bind.ValidationEventHandler) 778ea19b> @throws:JAXBException if an error was encountered while setting the event handler. 
<javax.xml.bind|Binder.getEventHandler() de7fd39f> Return the current event handler or the default event handler if one hasn't been set. 
<javax.xml.bind|Binder.getEventHandler() ef8f894b> @return:the current ValidationEventHandler or the default event handler if it hasn't been set. 
<javax.xml.bind|Binder.getEventHandler() 2fe6718a> @throws:JAXBException if an error was encountered while getting the current event handler. 
<javax.xml.bind|Binder.setProperty(java.lang.String,java.lang.Object) 83bc7f07> Set the particular property in the underlying implementation of Binder. 
<javax.xml.bind|Binder.setProperty(java.lang.String,java.lang.Object) b45c1b95> This method can only be used to set one of the standard JAXB defined unmarshal/marshal properties or a provider specific property for binder, unmarshal or marshal. 
<javax.xml.bind|Binder.setProperty(java.lang.String,java.lang.Object) 20c199f6> Attempting to set an undefined property will result in a PropertyException being thrown. 
<javax.xml.bind|Binder.setProperty(java.lang.String,java.lang.Object) 1054dd67> See Supported Unmarshal Properties and Supported Marshal Properties. 
<javax.xml.bind|Binder.setProperty(java.lang.String,java.lang.Object) 83af0b54> @throws:PropertyException when there is an error processing the given property or value. 
<javax.xml.bind|Binder.setProperty(java.lang.String,java.lang.Object) fd0d9b0b> @throws:IllegalArgumentException If the name parameter is null. 
<javax.xml.bind|Binder.getProperty(java.lang.String) 17b0e7fb> Get the particular property in the underlying implementation of Binder. 
<javax.xml.bind|Binder.getProperty(java.lang.String) 98dba121> This method can only be used to get one of the standard JAXB defined unmarshal/marshal properties or a provider specific property for binder, unmarshal or marshal. 
<javax.xml.bind|Binder.getProperty(java.lang.String) 893f95ea> Attempting to get an undefined property will result in a PropertyException being thrown. 
<javax.xml.bind|Binder.getProperty(java.lang.String) 1054dd67> See Supported Unmarshal Properties and Supported Marshal Properties. 
<javax.xml.bind|Binder.getProperty(java.lang.String) d7ee175b> @return:the value of the requested property. 
<javax.xml.bind|Binder.getProperty(java.lang.String) 33b30015> @throws:PropertyException when there is an error retrieving the given property or value property name. 
<javax.xml.bind|Binder.getProperty(java.lang.String) fd0d9b0b> @throws:IllegalArgumentException If the name parameter is null. 
