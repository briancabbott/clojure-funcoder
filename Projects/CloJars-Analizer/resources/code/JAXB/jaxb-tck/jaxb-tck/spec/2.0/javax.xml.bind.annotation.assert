<javax.xml.bind.annotation|XmlValue 1952f348>  Enables mapping a class to a XML Schema complex type with a simpleContent or a XML Schema simple type. 
<javax.xml.bind.annotation|XmlValue d5c9ba07> Usage: The @XmlValue annotation can be used with the following program elements: a JavaBean property. 
<javax.xml.bind.annotation|XmlValue 41578fe5> non static, non transient field. 
<javax.xml.bind.annotation|XmlValue 21c9934a> See "Package Specification" in javax.xml.bind.package javadoc for additional common information. 
<javax.xml.bind.annotation|XmlValue 35c7dc94> The usage is subject to the following usage constraints: At most one field or property can be annotated with the @XmlValue annotation. 
<javax.xml.bind.annotation|XmlValue d8750b56> @XmlValue can be used with the following annotations: {@link XmlList}. 
<javax.xml.bind.annotation|XmlValue 23ec7753> However this is redundant since {@link XmlList} maps a type to a simple schema type that derives by list just as {@link XmlValue} would. 
<javax.xml.bind.annotation|XmlValue 9d9c600f> If the type of the field or property is a collection type, then the collection item type must map to a simple schema type. 
<javax.xml.bind.annotation|XmlValue a6794047> If the type of the field or property is not a collection type, then the type must map to a XML Schema simple type. 
<javax.xml.bind.annotation|XmlValue 9ca2f28f> If the annotated JavaBean property is the sole class member being mapped to XML Schema construct, then the class is mapped to a simple type. 
<javax.xml.bind.annotation|XmlValue f3e2f158> If there are additional JavaBean properties (other than the JavaBean property annotated with @XmlValue annotation) that are mapped to XML attributes, then the class is mapped to a complex type with simpleContent. 
<javax.xml.bind.annotation|XmlValue 9e710b69> Example 1: Map a class to XML Schema simpleType // Example 1: Code fragment public class USPrice { &#64;XmlValue public java.math.BigDecimal price; } &lt;!-- Example 1: XML Schema fragment --> &lt;xs:simpleType name="USPrice"> &lt;xs:restriction base="xs:decimal"/> &lt;/xs:simpleType> Example 2: Map a class to XML Schema complexType with with simpleContent. 
<javax.xml.bind.annotation|XmlValue dc00b243> // Example 2: Code fragment public class InternationalPrice { &#64;XmlValue public java.math.BigDecimal price; &#64;XmlAttribute public String currency; } &lt;!-- Example 2: XML Schema fragment --> &lt;xs:complexType name="InternationalPrice"> &lt;xs:simpleContent> &lt;xs:extension base="xs:decimal"> &lt;xs:attribute name="currency" type="xs:string"/> &lt;/xs:extension> &lt;/xs:simpleContent> &lt;/xs:complexType> . 
<javax.xml.bind.annotation|XmlType d8b0005c>  Maps a class or an enum type to a XML Schema type. 
<javax.xml.bind.annotation|XmlType 4c4cd436> Usage The @XmlType annnotation can be used with the following program elements: a top level class an enum type See "Package Specification" in javax.xml.bind.package javadoc for additional common information. 
<javax.xml.bind.annotation|XmlType e0a239b> Mapping a Class A class maps to a XML Schema type. 
<javax.xml.bind.annotation|XmlType 6e0bd7a6> A class is a data container for values represented by properties and fields. 
<javax.xml.bind.annotation|XmlType 33bbaf8> A schema type is a data container for values represented by schema components within a schema type's content model (e.g. model groups, attributes etc). 
<javax.xml.bind.annotation|XmlType 3f015bef> To be mapped, a class must either have a public no-arg constructor or a static no-arg factory method. 
<javax.xml.bind.annotation|XmlType e8f75b52> The static factory method can be specified in factoryMethod() and factoryClass() annotation elements. 
<javax.xml.bind.annotation|XmlType 4862cb97> The static factory method or the no-arg constructor is used during unmarshalling to create an instance of this class. 
<javax.xml.bind.annotation|XmlType c743dc00> If both are present, the static factory method overrides the no-arg constructor. 
<javax.xml.bind.annotation|XmlType 694acc47> A class maps to either a XML Schema complex type or a XML Schema simple type. 
<javax.xml.bind.annotation|XmlType 408036ee> The XML Schema type is derived based on the mapping of JavaBean properties and fields contained within the class. 
<javax.xml.bind.annotation|XmlType d4cfadfe> The schema type to which the class is mapped can either be named or anonymous. 
<javax.xml.bind.annotation|XmlType abbf731c> A class can be mapped to an anonymous schema type by annotating the class with &#64XmlType(name=""). 
<javax.xml.bind.annotation|XmlType 7528837f> Either a global element, local element or a local attribute can be associated with an anonymous type as follows: global element: A global element of an anonymous type can be derived by annotating the class with @{@link XmlRootElement}. 
<javax.xml.bind.annotation|XmlType 977b7cfe> See Example 3 below. 
<javax.xml.bind.annotation|XmlType f262f8e5> local element: A JavaBean property that references a class annotated with @XmlType(name="") and is mapped to the element associated with the anonymous type. 
<javax.xml.bind.annotation|XmlType 977bf15d> See Example 4 below. 
<javax.xml.bind.annotation|XmlType 238f3d7e> attribute: A JavaBean property that references a class annotated with @XmlType(name="") and is mapped to the attribute associated with the anonymous type. 
<javax.xml.bind.annotation|XmlType 977c65bc> See Example 5 below. 
<javax.xml.bind.annotation|XmlType e04d8475> Mapping to XML Schema Complex Type If class is annotated with @XmlType(name="") , it is mapped to an anonymous type otherwise, the class name maps to a complex type name. 
<javax.xml.bind.annotation|XmlType 9d2f826> The XmlName() annotation element can be used to customize the name. 
<javax.xml.bind.annotation|XmlType 80e0403c> Properties and fields that are mapped to elements are mapped to a content model within a complex type. 
<javax.xml.bind.annotation|XmlType 797baeac> The annotation element propOrder() can be used to customize the content model to be xs:all or xs:sequence. 
<javax.xml.bind.annotation|XmlType e54fa4d7> It is used for specifying the order of XML elements in xs:sequence. 
<javax.xml.bind.annotation|XmlType 94088713> Properties and fields can be mapped to attributes within the complex type. 
<javax.xml.bind.annotation|XmlType 22ea92da> The targetnamespace of the XML Schema type can be customized using the annotation element namespace(). 
<javax.xml.bind.annotation|XmlType 31f8167> Mapping class to XML Schema simple type A class can be mapped to a XML Schema simple type using the @XmlValue annotation. 
<javax.xml.bind.annotation|XmlType f23e05d5> For additional details and examples, see @{@link XmlValue} annotation type. 
<javax.xml.bind.annotation|XmlType 7aca3296> The following table shows the mapping of the class to a XML Schema complex type or simple type. 
<javax.xml.bind.annotation|XmlType 710cdc59> The notational symbols used in the table are: -> : represents a mapping [x]+ : one or more occurances of x [ @XmlValue property ]: JavaBean property annotated with @XmlValue X : don't care Target propOrder ClassBody ComplexType SimpleType Class {} [property]+ -> elements complexcontentxs:all Class non empty [property]+ -> elements complexcontentxs:sequence Class X no property -> element complexcontentempty sequence Class X 1 [ @XmlValue property] && [property]+ ->attributes simplecontent Class X 1 [ @XmlValue property ]&& no properties -> attribute simpletype Mapping an enum type An enum type maps to a XML schema simple type with enumeration facets. 
<javax.xml.bind.annotation|XmlType 8e8bbfc5> The following annotation elements are ignored since they are not meaningful: propOrder() , factoryMethod() , factoryClass() . 
<javax.xml.bind.annotation|XmlType d37bae96> Usage with other annotations This annotation can be used with the following annotations: {@link XmlRootElement}, {@link XmlAccessorOrder}, {@link XmlAccessorType}, {@link XmlEnum}. 
<javax.xml.bind.annotation|XmlType 8293e3f3> However, {@link XmlAccessorOrder} and {@link XmlAccessorType} are ignored when this annotation is used on an enum type. 
<javax.xml.bind.annotation|XmlType ff7124ee> Example 1: Map a class to a complex type with xs:sequence with a customized ordering of JavaBean properties. 
<javax.xml.bind.annotation|XmlType 633d8024> &#64;XmlType(propOrder={"street", "city" , "state", "zip", "name" }) public class USAddress { String getName() {..}; void setName(String) {..}; String getStreet() {..}; void setStreet(String) {..}; String getCity() {..}; void setCity(String) {..}; String getState() {..}; void setState(String) {..}; java.math.BigDecimal getZip() {..}; void setZip(java.math.BigDecimal) {..}; } &lt;!-- XML Schema mapping for USAddress --> &lt;xs:complexType name="USAddress"> &lt;xs:sequence> &lt;xs:element name="street" type="xs:string"/> &lt;xs:element name="city" type="xs:string"/> &lt;xs:element name="state" type="xs:string"/> &lt;xs:element name="zip" type="xs:decimal"/> &lt;xs:element name="name" type="xs:string"/> &lt;/xs:all> &lt;/xs:complexType> Example 2: Map a class to a complex type with xs:all &#64;XmlType(propOrder={}) public class USAddress { ...} &lt;!-- XML Schema mapping for USAddress --> &lt;xs:complexType name="USAddress"> &lt;xs:all> &lt;xs:element name="name" type="xs:string"/> &lt;xs:element name="street" type="xs:string"/> &lt;xs:element name="city" type="xs:string"/> &lt;xs:element name="state" type="xs:string"/> &lt;xs:element name="zip" type="xs:decimal"/> &lt;/xs:sequence> &lt;/xs:complexType> Example 3: Map a class to a global element with an anonymous type. 
<javax.xml.bind.annotation|XmlType ee9920b4> &#64;XmlRootElement &#64;XmlType(name="") public class USAddress { ...} &lt;!-- XML Schema mapping for USAddress --> &lt;xs:element name="USAddress"> &lt;xs:complexType> &lt;xs:sequence> &lt;xs:element name="name" type="xs:string"/> &lt;xs:element name="street" type="xs:string"/> &lt;xs:element name="city" type="xs:string"/> &lt;xs:element name="state" type="xs:string"/> &lt;xs:element name="zip" type="xs:decimal"/> &lt;/xs:sequence> &lt;/xs:complexType> &lt;/xs:element> Example 4: Map a property to a local element with anonmyous type. 
<javax.xml.bind.annotation|XmlType a69376d4> //Example: Code fragment public class Invoice { USAddress addr; ... } &#64;XmlType(name="") public class USAddress { ... } } &lt;!-- XML Schema mapping for USAddress --> &lt;xs:complexType name="Invoice"> &lt;xs:sequence> &lt;xs:element name="addr"> &lt;xs:complexType> &lt;xs:element name="name", type="xs:string"/> &lt;xs:element name="city", type="xs:string"/> &lt;xs:element name="city" type="xs:string"/> &lt;xs:element name="state" type="xs:string"/> &lt;xs:element name="zip" type="xs:decimal"/> &lt;/xs:complexType> ... &lt;/xs:sequence> &lt;/xs:complexType> Example 5: Map a property to an attribute with anonymous type. 
<javax.xml.bind.annotation|XmlType 504f1d69> //Example: Code fragment public class Item { public String name; &#64;XmlAttribute public USPrice price; } // map class to anonymous simple type. 
<javax.xml.bind.annotation|XmlType e8c15063> &#64;XmlType(name="") public class USPrice { &#64;XmlValue public java.math.BigDecimal price; } &lt;!-- Example: XML Schema fragment --> &lt;xs:complexType name="Item"> &lt;xs:sequence> &lt;xs:element name="name" type="xs:string"/> &lt;xs:attribute name="price"> &lt;xs:simpleType> &lt;xs:restriction base="xs:decimal"/> &lt;/xs:simpleType> &lt;/xs:attribute> &lt;/xs:sequence> &lt;/xs:complexType> Example 6: Define a factoryClass and factoryMethod &#64;XmlType(name="USAddressType", factoryClass=USAddressFactory.class, factoryMethod="getUSAddress") public class USAddress { private String city; private String name; private String state; private String street; private int zip; public USAddress(String name, String street, String city, String state, int zip) { this.name = name; this.street = street; this.city = city; this.state = state; this.zip = zip; } } public class USAddressFactory { public static USAddress getUSAddress(){ return new USAddress("Mark Baker", "23 Elm St", "Dayton", "OH", 90952); } Example 7: Define factoryMethod and use the default factoryClass &#64;XmlType(name="USAddressType", factoryMethod="getNewInstance") public class USAddress { private String city; private String name; private String state; private String street; private int zip; private USAddress() {} public static USAddress getNewInstance(){ return new USAddress(); } } . 
<javax.xml.bind.annotation|XmlType.name() 4986665d> Name of the XML Schema type which the class is mapped. 
<javax.xml.bind.annotation|XmlType.propOrder() 9778349a> Specifies the order for XML Schema elements when class is mapped to a XML Schema complex type. 
<javax.xml.bind.annotation|XmlType.propOrder() 34a4d2c2> Refer to the table for how the propOrder affects the mapping of class The propOrder is a list of names of JavaBean properties in the class. 
<javax.xml.bind.annotation|XmlType.propOrder() 3a247e60> Each name in the list is the name of a Java identifier of the JavaBean property. 
<javax.xml.bind.annotation|XmlType.propOrder() da63e6c7> The order in which JavaBean properties are listed is the order of XML Schema elements to which the JavaBean properties are mapped. 
<javax.xml.bind.annotation|XmlType.propOrder() 93e906e2> All of the JavaBean properties being mapped to XML Schema elements must be listed. 
<javax.xml.bind.annotation|XmlType.propOrder() 9562cbe6> A JavaBean property or field listed in propOrder must not be transient or annotated with @XmlTransient. 
<javax.xml.bind.annotation|XmlType.propOrder() 8e4c7841> The default ordering of JavaBean properties is determined by @{@link XmlAccessorOrder}. 
<javax.xml.bind.annotation|XmlType.namespace() 15401ff8> Name of the target namespace of the XML Schema type. 
<javax.xml.bind.annotation|XmlType.namespace() 1428e575> By default, this is the target namespace to which the package containing the class is mapped. 
<javax.xml.bind.annotation|XmlType.factoryClass() 9ad4c204> Class containing a no-arg factory method for creating an instance of this class. 
<javax.xml.bind.annotation|XmlType.factoryClass() 2ab10db3> The default is this class. 
<javax.xml.bind.annotation|XmlType.factoryClass() 3422e725> If factoryClass is DEFAULT.class and factoryMethod is "", then there is no static factory method. 
<javax.xml.bind.annotation|XmlType.factoryClass() f62cc251> If factoryClass is DEFAULT.class and factoryMethod is not "", then factoryMethod is the name of a static factory method in this class. 
<javax.xml.bind.annotation|XmlType.factoryClass() bbf1a995> If factoryClass is not DEFAULT.class, then factoryMethod must not be "" and must be the name of a static factory method specified in factoryClass. 
<javax.xml.bind.annotation|XmlType.factoryMethod() ad0d26b0> Name of a no-arg factory method in the class specified in factoryClass factoryClass(). 
<javax.xml.bind.annotation|XmlType.DEFAULT bf485198> Used in {@link XmlType#factoryClass()} to signal that either factory mehod is not used or that it's in the class with this {@link XmlType} itself. 
<javax.xml.bind.annotation|XmlTransient 8db4b6f0>  Prevents the mapping of a JavaBean property to XML representation. 
<javax.xml.bind.annotation|XmlTransient d7b91389> The @XmlTransient annotation is useful for resolving name collisions between a JavaBean property name and a field name or preventing the mapping of a field/property. 
<javax.xml.bind.annotation|XmlTransient e4b427c3> A name collision can occur when the decapitalized JavaBean property name and a field name are the same. 
<javax.xml.bind.annotation|XmlTransient bcff072> If the JavaBean property refers to the field, then the name collision can be resolved by preventing the mapping of either the field or the JavaBean property using the @XmlTransient annotation. 
<javax.xml.bind.annotation|XmlTransient 5c8383c3> Usage The @XmlTransient annotation can be used with the following program elements: a JavaBean property field @XmlTransientis mutually exclusive with all other JAXB defined annotations. 
<javax.xml.bind.annotation|XmlTransient 21c9934a> See "Package Specification" in javax.xml.bind.package javadoc for additional common information. 
<javax.xml.bind.annotation|XmlTransient 6a25a6> Example: Resolve name collision between JavaBean property and field name // Example: Code fragment public class USAddress { // The field name "name" collides with the property name // obtained by bean decapitalization of getName() below &#64;XmlTransient public String name; String getName() {..}; String setName() {..}; } &lt;!-- Example: XML Schema fragment --> &lt;xs:complexType name="USAddress"> &lt;xs:sequence> &lt;xs:element name="name" type="xs:string"/> &lt;/xs:sequence> &lt;/xs:complexType> . 
<javax.xml.bind.annotation|XmlSchemaTypes a17c3407>  A container for multiple @{@link XmlSchemaType} annotations. 
<javax.xml.bind.annotation|XmlSchemaTypes feb589d1> Multiple annotations of the same type are not allowed on a program element. 
<javax.xml.bind.annotation|XmlSchemaTypes 4c952863> This annotation therefore serves as a container annotation for multiple &#64;XmlSchemaType annotations as follows: &#64;XmlSchemaTypes({ @XmlSchemaType(...), @XmlSchemaType(...) }) The @XmlSchemaTypes annnotation can be used to define {@link XmlSchemaType} for different types at the package level. 
<javax.xml.bind.annotation|XmlSchemaTypes 21c9934a> See "Package Specification" in javax.xml.bind.package javadoc for additional common information.. 
<javax.xml.bind.annotation|XmlSchemaTypes.value() dee40893> Collection of @{@link XmlSchemaType} annotations. 
<javax.xml.bind.annotation|XmlSchemaType 647e28d0> Maps a Java type to a simple schema built-in type. 
<javax.xml.bind.annotation|XmlSchemaType ebd88f65> Usage @XmlSchemaType annotation can be used with the following program elements: a JavaBean property field package @XmlSchemaType annotation defined for Java type applies to all references to the Java type from a property/field. 
<javax.xml.bind.annotation|XmlSchemaType 8b14b30c> A @XmlSchemaType annotation specified on the property/field overrides the @XmlSchemaType annotation specified at the package level. 
<javax.xml.bind.annotation|XmlSchemaType 7405acba> This annotation can be used with the following annotations: {@link XmlElement}, {@link XmlAttribute}. 
<javax.xml.bind.annotation|XmlSchemaType aadf2c7d> Example 1: Customize mapping of XMLGregorianCalendar on the field. 
<javax.xml.bind.annotation|XmlSchemaType be861b68> //Example: Code fragment public class USPrice { &#64;XmlElement &#64;XmlSchemaType(name="date") public XMLGregorianCalendar date; } &lt;!-- Example: Local XML Schema element --> &lt;xs:complexType name="USPrice"/> &lt;xs:sequence> &lt;xs:element name="date" type="xs:date"/> &lt;/sequence> &lt;/xs:complexType> Example 2: Customize mapping of XMLGregorianCalendar at package level package foo; &#64;javax.xml.bind.annotation.XmlSchemaType( name="date", type=javax.xml.datatype.XMLGregorianCalendar.class) } . 
<javax.xml.bind.annotation|XmlSchemaType.type() 58a83328> If this annotation is used at the package level, then value of the type() must be specified. 
<javax.xml.bind.annotation|XmlSchemaType.DEFAULT 5a2e2507> Used in {@link XmlSchemaType#type()} to signal that the type be inferred from the signature of the property. 
<javax.xml.bind.annotation|XmlSchema e5a31846>  Maps a package name to a XML namespace. 
<javax.xml.bind.annotation|XmlSchema 82573516> Usage The XmlSchema annotation can be used with the following program elements: package This is a package level annotation and follows the recommendations and restrictions contained in JSR 175, section III, "Annotations". 
<javax.xml.bind.annotation|XmlSchema 9e960e3> Thus the usage is subject to the following constraints and recommendations. 
<javax.xml.bind.annotation|XmlSchema a523c96c> There can only be one package declaration as noted in JSR 175, section III, "Annotations". 
<javax.xml.bind.annotation|XmlSchema 46798590> JSR 175 recommends package-info.java for package level annotations. 
<javax.xml.bind.annotation|XmlSchema c896924a> JAXB Providers that follow this recommendation will allow the package level annotations to be defined in package-info.java. 
<javax.xml.bind.annotation|XmlSchema 89d8e897> Example 1: Customize name of XML namespace to which package is mapped. 
<javax.xml.bind.annotation|XmlSchema fe9cb0e5> &#64;javax.xml.bind.annotation.XmlSchema ( namespace = "http://www.example.com/MYPO1" ) &lt;!-- XML Schema fragment --> &lt;schema xmlns=... 
<javax.xml.bind.annotation|XmlSchema 8c11aae9> xmlns:po=.... 
<javax.xml.bind.annotation|XmlSchema 5f64e528> targetNamespace="http://www.example.com/MYPO1" > &lt;!-- prefixes generated by default are implementation depedenent --> Example 2: Customize namespace prefix, namespace URI mapping // Package level annotation &#64;javax.xml.bind.annotation.XmlSchema ( xmlns = { &#64;javax.xml.bind.annotation.XmlNs(prefix = "po", namespaceURI="http://www.example.com/myPO1"), &#64;javax.xml.bind.annotation.XmlNs(prefix="xs", namespaceURI="http://www.w3.org/2001/XMLSchema") ) ) &lt;!-- XML Schema fragment --> &lt;schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:po="http://www.example.com/PO1" targetNamespace="http://www.example.com/PO1"> Example 3: Customize elementFormDefault &#64;javax.xml.bind.annotation.XmlSchema ( elementFormDefault=XmlNsForm.UNQUALIFIED ... ) &lt;!-- XML Schema fragment --> &lt;schema xmlns="http://www.w3.org/2001/XMLSchema" xmlns:po="http://www.example.com/PO1" elementFormDefault="unqualified"> . 
<javax.xml.bind.annotation|XmlSchema.xmlns() 765f9a9a> Customize the namespace URI, prefix associations. 
<javax.xml.bind.annotation|XmlSchema.xmlns() 54758da5> By default, the namespace prefixes for a XML namespace are generated by a JAXB Provider in an implementation dependent way. 
<javax.xml.bind.annotation|XmlSchema.namespace() f944d20b> Name of the XML namespace. 
<javax.xml.bind.annotation|XmlSchema.elementFormDefault() ccc73407> Namespace qualification for elements. 
<javax.xml.bind.annotation|XmlSchema.elementFormDefault() 70260a3> By default, element default attribute will be absent from the XML Schema fragment. 
<javax.xml.bind.annotation|XmlSchema.attributeFormDefault() da2a44d4> Namespace qualification for attributes. 
<javax.xml.bind.annotation|XmlSchema.attributeFormDefault() 7a77242c> By default, attributesFormDefault will be absent from the XML Schema fragment. 
<javax.xml.bind.annotation|XmlRootElement c084a7ed> Maps a class or an enum type to an XML element. 
<javax.xml.bind.annotation|XmlRootElement 7c721afb> Usage The &#64;XmlRootElement annotation can be used with the following program elements: a top level class an enum type See "Package Specification" in javax.xml.bind.package javadoc for additional common information. 
<javax.xml.bind.annotation|XmlRootElement 3a10b44a> When a top level class or an enum type is annotated with the &#64;XmlRootElement annotation, then its value is represented as XML element in an XML document. 
<javax.xml.bind.annotation|XmlRootElement 6fae903c> This annotation can be used with the following annotations: {@link XmlType}, {@link XmlEnum}, {@link XmlAccessorType}, {@link XmlAccessorOrder}. 
<javax.xml.bind.annotation|XmlRootElement b510a4a2> Example 1: Associate an element with XML Schema type // Example: Code fragment &#64;XmlRootElement class Point { int x; int y; Point(int _x,int _y) {x=_x;y=_y;} } //Example: Code fragment corresponding to XML output marshal( new Point(3,5), System.out); 3 5 The annotation causes an global element declaration to be produced in the schema. 
<javax.xml.bind.annotation|XmlRootElement 7ad37518> The global element declaration is associated with the XML schema type to which the class is mapped. 
<javax.xml.bind.annotation|XmlRootElement 7c30e363> Example 2: Orthogonality to type inheritance An element declaration annotated on a type is not inherited by its derived types. 
<javax.xml.bind.annotation|XmlRootElement d0301d9f> The following example shows this. 
<javax.xml.bind.annotation|XmlRootElement be83a888> // Example: Code fragment &#64;XmlRootElement class Point3D extends Point { int z; Point3D(int _x,int _y,int _z) {super(_x,_y);z=_z;} } //Example: Code fragment corresponding to XML output * marshal( new Point3D(3,5,0), System.out ); &lt;!-- Example: XML output --> &lt;!-- The element name is point3D not point --> &lt;point3D> &lt;x>3&lt;/x> &lt;y>5&lt;/y> &lt;z>0&lt;/z> &lt;/point3D> &lt;!-- Example: XML schema definition --> &lt;xs:element name="point3D" type="point3D"/> &lt;xs:complexType name="point3D"> &lt;xs:complexContent> &lt;xs:extension base="point"> &lt;xs:sequence> &lt;xs:element name="z" type="xs:int"/> &lt;/xs:sequence> &lt;/xs:extension> &lt;/xs:complexContent> &lt;/xs:complexType> Example 3: Associate a global element with XML Schema type to which the class is mapped. 
<javax.xml.bind.annotation|XmlRootElement 8ead7a69> //Example: Code fragment &#64;XmlRootElement(name="PriceElement") public class USPrice { &#64;XmlElement public java.math.BigDecimal price; } &lt;!-- Example: XML schema definition --> &lt;xs:element name="PriceElement" type="USPrice"/> &lt;xs:complexType name="USPrice"> &lt;xs:sequence> &lt;xs:element name="price" type="xs:decimal"/> &lt;/sequence> &lt;/xs:complexType> . 
<javax.xml.bind.annotation|XmlRootElement.namespace() 16e2c10a> namespace name of the XML element. 
<javax.xml.bind.annotation|XmlRootElement.namespace() 245bfde> If the value is "##default", then the XML namespace name is derived from the package of the class ( {@link XmlSchema} ). 
<javax.xml.bind.annotation|XmlRootElement.namespace() 4232d2eb> If the package is unnamed, then the XML namespace is the default empty namespace. 
<javax.xml.bind.annotation|XmlRootElement.name() d821fa58> local name of the XML element. 
<javax.xml.bind.annotation|XmlRootElement.name() cabe9b0e> If the value is "##default", then the name is derived from the class name. 
<javax.xml.bind.annotation|XmlRegistry 27bfdc54> Marks a class that has {@link XmlElementDecl}s. 
<javax.xml.bind.annotation|XmlNsForm e4a7644d> Enumeration of XML Schema namespace qualifications. 
<javax.xml.bind.annotation|XmlNsForm 21c9934a> See "Package Specification" in javax.xml.bind.package javadoc for additional common information. 
<javax.xml.bind.annotation|XmlNsForm 40edbce8> Usage The namespace qualification values are used in the annotations defined in this packge. 
<javax.xml.bind.annotation|XmlNsForm d7f63d4a> The enumeration values are mapped as follows: Enum Value XML Schema Value UNQUALIFIED unqualified QUALIFIED qualified UNSET namespace qualification attribute is absent from the XML Schema fragment . 
<javax.xml.bind.annotation|XmlNs ec83b330>  Associates a namespace prefix with a XML namespace URI. 
<javax.xml.bind.annotation|XmlNs 6908b5d4> Usage @XmlNs annotation is intended for use from other program annotations. 
<javax.xml.bind.annotation|XmlNs 21c9934a> See "Package Specification" in javax.xml.bind.package javadoc for additional common information. 
<javax.xml.bind.annotation|XmlNs c627398c> Example:See XmlSchema annotation type for an example. 
<javax.xml.bind.annotation|XmlNs.prefix() 787aea5b> Namespace prefix. 
<javax.xml.bind.annotation|XmlNs.namespaceURI() c1eb0dcb> Namespace URI. 
<javax.xml.bind.annotation|XmlMixed e80da87e>  Annotate a JavaBean multi-valued property to support mixed content. 
<javax.xml.bind.annotation|XmlMixed 33ab6bfd> The usage is subject to the following constraints: can be used with &#64;XmlElementRef, &#64;XmlElementRefs or &#64;XmlAnyElement The following can be inserted into &#64;XmlMixed annotated multi-valued property XML text information items are added as values of java.lang.String. 
<javax.xml.bind.annotation|XmlMixed ad4d2675> Children element information items are added as instances of {@link JAXBElement} or instances with a class that is annotated with &#64;XmlRootElement. 
<javax.xml.bind.annotation|XmlMixed ebe44c5> Unknown content that is not be bound to a JAXB mapped class is inserted as {@link Element}. 
<javax.xml.bind.annotation|XmlMixed e57946d2> (Assumes property annotated with &#64;XmlAnyElement) Below is an example of binding and creation of mixed content. 
<javax.xml.bind.annotation|XmlMixed 5e583622> // Schema-derived Java code: // (Only annotations relevant to mixed content are shown below, // others are ommitted.) import java.math.BigInteger; public class ObjectFactory { // element instance factories JAXBElement createLetterBody(LetterBody value); JAXBElement createLetterBodyName(String value); JAXBElement createLetterBodyQuantity(BigInteger value); JAXBElement createLetterBodyProductName(String value); // type instance factory LetterBody> createLetterBody(); } public class LetterBody { // Mixed content can contain instances of Element classes // Name, Quantity and ProductName. 
<javax.xml.bind.annotation|XmlMixed adff4525> Text data is represented as // java.util.String for text. 
<javax.xml.bind.annotation|XmlMixed 59455e76> &#64;XmlMixed &#64;XmlElementRefs({ &#64;XmlElementRef(name="productName", type=JAXBElement.class), &#64;XmlElementRef(name="quantity", type=JAXBElement.class), &#64;XmlElementRef(name="name", type=JAXBElement.class)}) List getContent(){...} } The following is an XML instance document with mixed content Dear Mr.Robert Smith Your order of 1 Baby Monitor shipped from our warehouse. 
<javax.xml.bind.annotation|XmlMixed 47cb84be> .... that can be constructed using following JAXB API calls. 
<javax.xml.bind.annotation|XmlMixed 72c9c900> LetterBody lb = ObjectFactory.createLetterBody(); JAXBElement lbe = ObjectFactory.createLetterBody(lb); List gcl = lb.getContent(); //add mixed content to general content property. 
<javax.xml.bind.annotation|XmlMixed 74fe880f> gcl.add("Dear Mr."); // add text information item as a String. 
<javax.xml.bind.annotation|XmlMixed ff9447b5> // add child element information item gcl.add(ObjectFactory.createLetterBodyName("Robert Smith")); gcl.add("Your order of "); // add text information item as a String // add children element information items gcl.add(ObjectFactory. 
<javax.xml.bind.annotation|XmlMixed 1e4a1561> createLetterBodyQuantity(new BigInteger("1"))); gcl.add(ObjectFactory.createLetterBodyProductName("Baby Monitor")); gcl.add("shipped from our warehouse"); // add text information item See "Package Specification" in javax.xml.bind.package javadoc for additional common information.. 
<javax.xml.bind.annotation|XmlMimeType 3568431c> Associates the MIME type that controls the XML representation of the property. 
<javax.xml.bind.annotation|XmlMimeType 2e3ea76e> This annotation is used in conjunction with datatypes such as {@link Image} or {@link Source} that are bound to base64-encoded binary in XML. 
<javax.xml.bind.annotation|XmlMimeType 2bfca4> If a property that has this annotation has a sibling property bound to the xmime:contentType attribute, and if in the instance the property has a value, the value of the attribute takes precedence and that will control the marshalling. 
<javax.xml.bind.annotation|XmlMimeType.value() 5c2fb9e> The textual representation of the MIME type, such as "image/jpeg" "image/*", "text/xml; charset=iso-8859-1" and so on. 
<javax.xml.bind.annotation|XmlList f011a2ed> Used to map a property to a list simple type. 
<javax.xml.bind.annotation|XmlList c49df05f> Usage The @XmlList annotation can be used with the following program elements: JavaBean property field When a collection property is annotated just with @XmlElement, each item in the collection will be wrapped by an element. 
<javax.xml.bind.annotation|XmlList d963bf2e> For example, &#64;XmlRootElement class Foo { &#64;XmlElement List&lt;String> data; } would produce XML like this: abc def &#64;XmlList annotation, on the other hand, allows multiple values to be represented as whitespace-separated tokens in a single element. 
<javax.xml.bind.annotation|XmlList 8b1100c3> For example, &#64;XmlRootElement class Foo { &#64;XmlElement &#64;XmlList List&lt;String> data; } the above code will produce XML like this: abc def This annotation can be used with the following annotations: {@link XmlElement}, {@link XmlAttribute}, {@link XmlValue}, {@link XmlIDREF}. 
<javax.xml.bind.annotation|XmlList 8bb88f55> The use of @XmlList with {@link XmlValue} while allowed, is redundant since {@link XmlList} maps a collection type to a simple schema type that derives by list just as {@link XmlValue} would. 
<javax.xml.bind.annotation|XmlList 36e94319> The use of @XmlList with {@link XmlAttribute} while allowed, is redundant since {@link XmlList} maps a collection type to a simple schema type that derives by list just as {@link XmlAttribute} would. 
<javax.xml.bind.annotation|XmlInlineBinaryData 468b580c> Disable consideration of XOP encoding for datatypes that are bound to base64-encoded binary data in XML. 
<javax.xml.bind.annotation|XmlInlineBinaryData 22539cbb> When XOP encoding is enabled as described in {@link AttachmentMarshaller#isXOPPackage()}, this annotation disables datatypes such as {@link Image} or {@link Source} or byte[] that are bound to base64-encoded binary from being considered for XOP encoding. 
<javax.xml.bind.annotation|XmlInlineBinaryData 9e21ee6b> If a JAXB property is annotated with this annotation or if the JAXB property's base type is annotated with this annotation, neither {@link AttachmentMarshaller#addMtomAttachment(DataHandler, String, String)} nor {@link AttachmentMarshaller#addMtomAttachment(byte[], int, int, String, String, String)} is ever called for the property. 
<javax.xml.bind.annotation|XmlInlineBinaryData b94c2e91> The binary data will always be inlined. 
<javax.xml.bind.annotation|XmlIDREF 81c5b5a4>  Maps a JavaBean property to XML IDREF. 
<javax.xml.bind.annotation|XmlIDREF b77117e7> To preserve referential integrity of an object graph across XML serialization followed by a XML deserialization, requires an object reference to be marshalled by reference or containment appropriately. 
<javax.xml.bind.annotation|XmlIDREF 958b5f01> Annotations &#64;XmlID and &#64;XmlIDREF together allow a customized mapping of a JavaBean property's type by containment or reference. 
<javax.xml.bind.annotation|XmlIDREF d3a34e5d> Usage The &#64;XmlIDREF annotation can be used with the following program elements: a JavaBean property non static, non transient field See "Package Specification" in javax.xml.bind.package javadoc for additional common information. 
<javax.xml.bind.annotation|XmlIDREF 6f385321> The usage is subject to the following constraints: If the type of the field or property is a collection type, then the collection item type must contain a property or field annotated with &#64;XmlID. 
<javax.xml.bind.annotation|XmlIDREF e8c98657> If the field or property is single valued, then the type of the property or field must contain a property or field annotated with &#64;XmlID. 
<javax.xml.bind.annotation|XmlIDREF 1874bc91> Note: If the collection item type or the type of the property (for non collection type) is java.lang.Object, then the instance must contain a property/field annotated with &#64;XmlID attribute. 
<javax.xml.bind.annotation|XmlIDREF c8a6dc97> This annotation can be used with the following annotations: {@link XmlElement}, {@link XmlAttribute}, {@link XmlList}, and {@link XmlElements}. 
<javax.xml.bind.annotation|XmlIDREF 32c4201c> Example: Map a JavaBean property to xs:IDREF (i.e. by reference rather than by containment) //EXAMPLE: Code fragment public class Shipping { &#64;XmlIDREF public Customer getCustomer(); public void setCustomer(Customer customer); .... } &lt;!-- Example: XML Schema fragment --> &lt;xs:complexType name="Shipping"> &lt;xs:complexContent> &lt;xs:sequence> &lt;xs:element name="customer" type="xs:IDREF"/> .... &lt;/xs:sequence> &lt;/xs:complexContent> &lt;/xs:complexType> Example 2: The following is a complete example of containment versus reference. 
<javax.xml.bind.annotation|XmlIDREF 67c19d5> // By default, Customer maps to complex type xs:Customer public class Customer { // map JavaBean property type to xs:ID &#64;XmlID public String getCustomerID(); public void setCustomerID(String id); // .... other properties not shown } // By default, Invoice maps to a complex type xs:Invoice public class Invoice { // map by reference &#64;XmlIDREF public Customer getCustomer(); public void setCustomer(Customer customer); // .... other properties not shown here } // By default, Shipping maps to complex type xs:Shipping public class Shipping { // map by reference &#64;XmlIDREF public Customer getCustomer(); public void setCustomer(Customer customer); } // at least one class must reference Customer by containment; // Customer instances won't be marshalled. 
<javax.xml.bind.annotation|XmlIDREF 3129ebd0> &#64;XmlElement(name="CustomerData") public class CustomerData { // map reference to Customer by containment by default. 
<javax.xml.bind.annotation|XmlIDREF 55091236> public Customer getCustomer(); // maps reference to Shipping by containment by default. 
<javax.xml.bind.annotation|XmlIDREF 8ee1947b> public Shipping getShipping(); // maps reference to Invoice by containment by default. 
<javax.xml.bind.annotation|XmlIDREF ec266b04> public Invoice getInvoice(); } &lt;!-- XML Schema mapping for above code frament --> &lt;xs:complexType name="Invoice"> &lt;xs:complexContent> &lt;xs:sequence> &lt;xs:element name="customer" type="xs:IDREF"/> .... &lt;/xs:sequence> &lt;/xs:complexContent> &lt;/xs:complexType> &lt;xs:complexType name="Shipping"> &lt;xs:complexContent> &lt;xs:sequence> &lt;xs:element name="customer" type="xs:IDREF"/> .... &lt;/xs:sequence> &lt;/xs:complexContent> &lt;/xs:complexType> &lt;xs:complexType name="Customer"> &lt;xs:complexContent> &lt;xs:sequence> .... &lt;/xs:sequence> &lt;xs:attribute name="CustomerID" type="xs:ID"/> &lt;/xs:complexContent> &lt;/xs:complexType> &lt;xs:complexType name="CustomerData"> &lt;xs:complexContent> &lt;xs:sequence> &lt;xs:element name="customer" type="xs:Customer"/> &lt;xs:element name="shipping" type="xs:Shipping"/> &lt;xs:element name="invoice" type="xs:Invoice"/> &lt;/xs:sequence> &lt;/xs:complexContent> &lt;/xs:complexType> &lt;xs:element name"customerData" type="xs:CustomerData"/> &lt;!-- Instance document conforming to the above XML Schema --> &lt;customerData> &lt;customer customerID="Alice"> .... &lt;/customer> &lt;shipping customer="Alice"> .... &lt;/shipping> &lt;invoice customer="Alice"> .... &lt;/invoice> &lt;/customerData> Example 3: Mapping List to repeating element of type IDREF // Code fragment public class Shipping { &#64;XmlIDREF &#64;XmlElement(name="Alice") public List customers; } &lt;!-- XML schema fragment --> &lt;xs:complexType name="Shipping"> &lt;xs:sequence> &lt;xs:choice minOccurs="0" maxOccurs="unbounded"> &lt;xs:element name="Alice" type="xs:IDREF"/> &lt;/xs:choice> &lt;/xs:sequence> &lt;/xs:complexType> Example 4: Mapping a List to a list of elements of type IDREF. 
<javax.xml.bind.annotation|XmlIDREF 6fef6e74> //Code fragment public class Shipping { &#64;XmlIDREF &#64;XmlElements( &#64;XmlElement(name="Alice", type="Customer.class") &#64;XmlElement(name="John", type="InternationalCustomer.class") public List customers; } &lt;!-- XML Schema fragment --> &lt;xs:complexType name="Shipping"> &lt;xs:sequence> &lt;xs:choice minOccurs="0" maxOccurs="unbounded"> &lt;xs:element name="Alice" type="xs:IDREF"/> &lt;xs:element name="John" type="xs:IDREF"/> &lt;/xs:choice> &lt;/xs:sequence> &lt;/xs:complexType> . 
<javax.xml.bind.annotation|XmlID 18e8c370>  Maps a JavaBean property to XML ID. 
<javax.xml.bind.annotation|XmlID b77117e7> To preserve referential integrity of an object graph across XML serialization followed by a XML deserialization, requires an object reference to be marshalled by reference or containment appropriately. 
<javax.xml.bind.annotation|XmlID 958b5f01> Annotations &#64;XmlID and &#64;XmlIDREF together allow a customized mapping of a JavaBean property's type by containment or reference. 
<javax.xml.bind.annotation|XmlID 317e0611> Usage The &#64;XmlID annotation can be used with the following program elements: a JavaBean property non static, non transient field See "Package Specification" in javax.xml.bind.package javadoc for additional common information. 
<javax.xml.bind.annotation|XmlID 7b8cf628> The usage is subject to the following constraints: At most one field or property in a class can be annotated with &#64;XmlID. 
<javax.xml.bind.annotation|XmlID fdc79192> The JavaBean property's type must be java.lang.String. 
<javax.xml.bind.annotation|XmlID fba96ec6> The only other mapping annotations that can be used with &#64;XmlID are:&#64;XmlElement and &#64;XmlAttribute. 
<javax.xml.bind.annotation|XmlID d39686a5> Example: Map a JavaBean property's type to xs:ID // Example: code fragment public class Customer { &#64;XmlAttribute &#64;XmlID public String getCustomerID(); public void setCustomerID(String id); .... other properties not shown } &lt;!-- Example: XML Schema fragment --> &lt;xs:complexType name="Customer"> &lt;xs:complexContent> &lt;xs:sequence> .... &lt;/xs:sequence> &lt;xs:attribute name="customerID" type="xs:ID"/> &lt;/xs:complexContent> &lt;/xs:complexType> . 
<javax.xml.bind.annotation|XmlEnumValue 787e7e54> Maps an enum constant in {@link Enum} type to XML representation. 
<javax.xml.bind.annotation|XmlEnumValue a124d832> Usage The @XmlEnumValue annotation can be used with the following program elements: enum constant See "Package Specification" in javax.xml.bind.package javadoc for additional common information. 
<javax.xml.bind.annotation|XmlEnumValue 531bfa27> This annotation, together with {@link XmlEnum} provides a mapping of enum type to XML representation. 
<javax.xml.bind.annotation|XmlEnumValue c33e11d6> An enum type is mapped to a schema simple type with enumeration facets. 
<javax.xml.bind.annotation|XmlEnumValue 1984c9ae> The schema type is derived from the Java type specified in @XmlEnum.value(). 
<javax.xml.bind.annotation|XmlEnumValue 6939833> Each enum constant @XmlEnumValue must have a valid lexical representation for the type @XmlEnum.value() In the absence of this annotation, {@link Enum#name()} is used as the XML representation. 
<javax.xml.bind.annotation|XmlEnumValue e153419d> Example 1: Map enum constant name -> enumeration facet //Example: Code fragment &#64;XmlEnum(String.class) public enum Card { CLUBS, DIAMONDS, HEARTS, SPADES } &lt;!-- Example: XML Schema fragment --> &lt;xs:simpleType name="Card"> &lt;xs:restriction base="xs:string"/> &lt;xs:enumeration value="CLUBS"/> &lt;xs:enumeration value="DIAMONDS"/> &lt;xs:enumeration value="HEARTS"/> &lt;xs:enumeration value="SPADES"/> &lt;/xs:simpleType> Example 2: Map enum constant name(value) -> enumeration facet //Example: code fragment &#64;XmlType &#64;XmlEnum(Integer.class) public enum Coin { &#64;XmlEnumValue("1") PENNY(1), &#64;XmlEnumValue("5") NICKEL(5), &#64;XmlEnumValue("10") DIME(10), &#64;XmlEnumValue("25") QUARTER(25) } &lt;!-- Example: XML Schema fragment --> &lt;xs:simpleType name="Coin"> &lt;xs:restriction base="xs:int"> &lt;xs:enumeration value="1"/> &lt;xs:enumeration value="5"/> &lt;xs:enumeration value="10"/> &lt;xs:enumeration value="25"/> &lt;/xs:restriction> &lt;/xs:simpleType> Example 3: Map enum constant name -> enumeration facet //Code fragment &#64;XmlType &#64;XmlEnum(Integer.class) public enum Code { &#64;XmlEnumValue("1") ONE, &#64;XmlEnumValue("2") TWO; } &lt;!-- Example: XML Schema fragment --> &lt;xs:simpleType name="Code"> &lt;xs:restriction base="xs:int"> &lt;xs:enumeration value="1"/> &lt;xs:enumeration value="2"/> &lt;/xs:restriction> &lt;/xs:simpleType> . 
<javax.xml.bind.annotation|XmlEnum 26bbc88a>  Maps an enum type {@link Enum} to XML representation. 
<javax.xml.bind.annotation|XmlEnum 44074b71> This annotation, together with {@link XmlEnumValue} provides a mapping of enum type to XML representation. 
<javax.xml.bind.annotation|XmlEnum a754d953> Usage The @XmlEnum annotation can be used with the following program elements: enum type The usage is subject to the following constraints: This annotation can be used the following other annotations: {@link XmlType}, {@link XmlRootElement} See "Package Specification" in javax.xml.bind.package javadoc for additional common information An enum type is mapped to a schema simple type with enumeration facets. 
<javax.xml.bind.annotation|XmlEnum a934aa00> The schema type is derived from the Java type to which @XmlEnum.value(). 
<javax.xml.bind.annotation|XmlEnum c9e464d0> Each enum constant @XmlEnumValue must have a valid lexical representation for the type @XmlEnum.value() . 
<javax.xml.bind.annotation|XmlEnum 64ab72d8> Examples: See examples in {@link XmlEnumValue}. 
<javax.xml.bind.annotation|XmlEnum.value() 9951b4c9> Java type that is mapped to a XML simple type. 
<javax.xml.bind.annotation|XmlElementWrapper ce566002> Generates a wrapper element around XML representation. 
<javax.xml.bind.annotation|XmlElementWrapper 2b23932e> This is primarily intended to be used to produce a wrapper XML element around collections. 
<javax.xml.bind.annotation|XmlElementWrapper f66ad277> The annotation therefore supports two forms of serialization shown below. 
<javax.xml.bind.annotation|XmlElementWrapper 46ebc344> //Example: code fragment int[] names; // XML Serialization Form 1 (Unwrapped collection) &lt;names> ... &lt;/names> &lt;names> ... &lt;/names> // XML Serialization Form 2 ( Wrapped collection ) &lt;wrapperElement> &lt;names> value-of-item &lt;/names> &lt;names> value-of-item &lt;/names> .... &lt;/wrapperElement> The two serialized XML forms allow a null collection to be represented either by absence or presence of an element with a nillable attribute. 
<javax.xml.bind.annotation|XmlElementWrapper ffe3af6e> Usage The @XmlElementWrapper annotation can be used with the following program elements: JavaBean property non static, non transient field The usage is subject to the following constraints: The property must be a collection property This annotation can be used with the following annotations: {@link XmlElement}, {@link XmlElements}, {@link XmlElementRef}, {@link XmlElementRefs}, {@link XmlJavaTypeAdapter}. 
<javax.xml.bind.annotation|XmlElementWrapper 21c9934a> See "Package Specification" in javax.xml.bind.package javadoc for additional common information.. 
<javax.xml.bind.annotation|XmlElementWrapper.name() e74809c2> Name of the XML wrapper element. 
<javax.xml.bind.annotation|XmlElementWrapper.name() 6b9c78c1> By default, the XML wrapper element name is derived from the JavaBean property name. 
<javax.xml.bind.annotation|XmlElementWrapper.namespace() 9b58767c> XML target namespace of the XML wrapper element. 
<javax.xml.bind.annotation|XmlElementWrapper.namespace() dcf84344> If the value is "##default", then the namespace is determined as follows: If the enclosing package has {@link XmlSchema} annotation, and its {@link XmlSchema#elementFormDefault() elementFormDefault} is {@link XmlNsForm#QUALIFIED QUALIFIED}, then the namespace of the enclosing class. 
<javax.xml.bind.annotation|XmlElementWrapper.namespace() 99d85e5b> Otherwise "" (which produces unqualified element in the default namespace. 
<javax.xml.bind.annotation|XmlElementWrapper.nillable() 5e62d5cf> If true, the absence of the collection is represented by using xsi:nil='true'. 
<javax.xml.bind.annotation|XmlElementWrapper.nillable() c3a0942a> Otherwise, it is represented by the absence of the element. 
<javax.xml.bind.annotation|XmlElements 3d4422a0>  A container for multiple @{@link XmlElement} annotations. 
<javax.xml.bind.annotation|XmlElements feb589d1> Multiple annotations of the same type are not allowed on a program element. 
<javax.xml.bind.annotation|XmlElements 7d7f7e6a> This annotation therefore serves as a container annotation for multiple &#64;XmlElements as follows: &#64;XmlElements({ @XmlElement(...),@XmlElement(...) }) The @XmlElements annnotation can be used with the following program elements: a JavaBean property non static, non transient field This annotation is intended for annotation a JavaBean collection property (e.g. List). 
<javax.xml.bind.annotation|XmlElements af402dc1> Usage The usage is subject to the following constraints: This annotation can be used with the following annotations: @{@link XmlIDREF}, @{@link XmlElementWrapper}. 
<javax.xml.bind.annotation|XmlElements befeb4f9> If @XmlIDREF is also specified on the JavaBean property, then each &#64;XmlElement.type() must contain a JavaBean property annotated with &#64;XmlID. 
<javax.xml.bind.annotation|XmlElements 21c9934a> See "Package Specification" in javax.xml.bind.package javadoc for additional common information. 
<javax.xml.bind.annotation|XmlElements b093c3ff> Example 1: Map to a list of elements // Mapped code fragment public class Foo { &#64;XmlElements( &#64;XmlElement(name="A", type=Integer.class), &#64;XmlElement(name="B", type=Float.class) } public List items; } &lt;!-- XML Representation for a List of {1,2.5} XML output is not wrapped using another element --> ... 1 2.5 ... &lt;!-- XML Schema fragment --> &lt;xs:complexType name="Foo"> &lt;xs:sequence> &lt;xs:choice minOccurs="0" maxOccurs="unbounded"> &lt;xs:element name="A" type="xs:int"/> &lt;xs:element name="B" type="xs:float"/> &lt;xs:choice> &lt;/xs:sequence> &lt;/xs:complexType> Example 2: Map to a list of elements wrapped with another element // Mapped code fragment public class Foo { &#64;XmlElementWrapper(name="bar") &#64;XmlElements( &#64;XmlElement(name="A", type=Integer.class), &#64;XmlElement(name="B", type=Float.class) } public List items; } &lt;!-- XML Schema fragment --> &lt;xs:complexType name="Foo"> &lt;xs:sequence> &lt;xs:element name="bar"> &lt;xs:complexType> &lt;xs:choice minOccurs="0" maxOccurs="unbounded"> &lt;xs:element name="A" type="xs:int"/> &lt;xs:element name="B" type="xs:float"/> &lt;/xs:choice> &lt;/xs:complexType> &lt;/xs:element> &lt;/xs:sequence> &lt;/xs:complexType> Example 3: Change element name based on type using an adapter. 
<javax.xml.bind.annotation|XmlElements b9901c6e> class Foo { &#64;XmlJavaTypeAdapter(QtoPAdapter.class) &#64;XmlElements({ &#64;XmlElement(name="A",type=PX.class), &#64;XmlElement(name="B",type=PY.class) }) Q bar; } &#64;XmlType abstract class P {...} &#64;XmlType(name="PX") class PX extends P {...} &#64;XmlType(name="PY") class PY extends P {...} &lt;!-- XML Schema fragment --> &lt;xs:complexType name="Foo"> &lt;xs:sequence> &lt;xs:element name="bar"> &lt;xs:complexType> &lt;xs:choice minOccurs="0" maxOccurs="unbounded"> &lt;xs:element name="A" type="PX"/> &lt;xs:element name="B" type="PY"/> &lt;/xs:choice> &lt;/xs:complexType> &lt;/xs:element> &lt;/xs:sequence> &lt;/xs:complexType> . 
<javax.xml.bind.annotation|XmlElements.value() db037994> Collection of @{@link XmlElement} annotations. 
<javax.xml.bind.annotation|XmlElementRefs 4fa42556> Marks a property that refers to classes with {@link XmlElement} or JAXBElement. 
<javax.xml.bind.annotation|XmlElementRefs 4893e4b5> Compared to an element property (property with {@link XmlElement} annotation), a reference property has a different substitution semantics. 
<javax.xml.bind.annotation|XmlElementRefs 2ce6359f> When a sub-class is assigned to a property, an element property produces the same tag name with @xsi:type, whereas a reference property produces a different tag name (the tag name that's on the the sub-class.) This annotation can be used with the following annotations: {@link XmlJavaTypeAdapter}, {@link XmlElementWrapper}. 
<javax.xml.bind.annotation|XmlElementRef 3b10ec4b>  Maps a JavaBean property to a XML element derived from property's type. 
<javax.xml.bind.annotation|XmlElementRef 8e0960c1> Usage &#64;XmlElementRef annotation can be used with a JavaBean property or from within {@link XmlElementRefs} This annotation dynamically associates an XML element name with the JavaBean property. 
<javax.xml.bind.annotation|XmlElementRef 1ac3f701> When a JavaBean property is annotated with {@link XmlElement}, the XML element name is statically derived from the JavaBean property name. 
<javax.xml.bind.annotation|XmlElementRef e52044f7> However, when this annotation is used, the XML element name is derived from the instance of the type of the JavaBean property at runtime. 
<javax.xml.bind.annotation|XmlElementRef 7278173f> XML Schema substitution group support XML Schema allows a XML document author to use XML element names that were not statically specified in the content model of a schema using substitution groups. 
<javax.xml.bind.annotation|XmlElementRef 59aa3cf9> Schema derived code provides support for substitution groups using an element property, (section 5.5.5, "Element Property" of JAXB 2.0 specification). 
<javax.xml.bind.annotation|XmlElementRef 11db93fb> An element property method signature is of the form: public void setTerm(JAXBElement); public JAXBElement getTerm(); An element factory method annotated with {@link XmlElementDecl} is used to create a JAXBElement instance, containing an XML element name. 
<javax.xml.bind.annotation|XmlElementRef b39a86c4> The presence of &#64;XmlElementRef annotation on an element property indicates that the element name from JAXBElement instance be used instead of deriving an XML element name from the JavaBean property name. 
<javax.xml.bind.annotation|XmlElementRef 2eb00b25> The usage is subject to the following constraints: If the collection item type (for collection property) or property type (for single valued property) is {@link javax.xml.bind.JAXBElement}, then &#64;XmlElementRef}.name() and &#64;XmlElementRef.namespace() must point an element factory method with an @XmlElementDecl annotation in a class annotated with @XmlRegistry (usually ObjectFactory class generated by the schema compiler) : @XmlElementDecl.name() must equal @XmlElementRef.name() @XmlElementDecl.namespace() must equal @XmlElementRef.namespace(). 
<javax.xml.bind.annotation|XmlElementRef 9f62c05a> If the collection item type (for collection property) or property type (for single valued property) is not {@link javax.xml.bind.JAXBElement}, then the type referenced by the property or field must be annotated with {@link XmlRootElement}. 
<javax.xml.bind.annotation|XmlElementRef 7967c83c> This annotation can be used with the following annotations: {@link XmlElementWrapper}, {@link XmlJavaTypeAdapter}. 
<javax.xml.bind.annotation|XmlElementRef 21c9934a> See "Package Specification" in javax.xml.bind.package javadoc for additional common information. 
<javax.xml.bind.annotation|XmlElementRef cf5f1dac> Example 1: Ant Task Example The following Java class hierarchy models an Ant build script. 
<javax.xml.bind.annotation|XmlElementRef d087832f> An Ant task corresponds to a class in the class hierarchy. 
<javax.xml.bind.annotation|XmlElementRef 5755c3fe> The XML element name of an Ant task is indicated by the &#64;XmlRootElement annotation on its corresponding class. 
<javax.xml.bind.annotation|XmlElementRef 98d3b556> &#64;XmlRootElement(name="target") class Target { // The presence of &#64;XmlElementRef indicates that the XML // element name will be derived from the &#64;XmlRootElement // annotation on the type (for e.g. "jar" for JarTask). 
<javax.xml.bind.annotation|XmlElementRef e4c512a> &#64;XmlElementRef List&lt;Task> tasks; } abstract class Task { } &#64;XmlRootElement(name="jar") class JarTask extends Task { ... } &#64;XmlRootElement(name="javac") class JavacTask extends Task { ... } &lt;!-- XML Schema fragment --> &lt;xs:element name="target" type="Target"> &lt;xs:complexType name="Target"> &lt;xs:sequence> &lt;xs:choice maxOccurs="unbounded"> &lt;xs:element ref="jar"> &lt;xs:element ref="javac"> &lt;/xs:choice> &lt;/xs:sequence> &lt;/xs:complexType> Thus the following code fragment: Target target = new Target(); target.tasks.add(new JarTask()); target.tasks.add(new JavacTask()); marshal(target); will produce the following XML output: .... .... It is not an error to have a class that extends Task that doesn't have {@link XmlRootElement}. 
<javax.xml.bind.annotation|XmlElementRef 39355f25> But they can't show up in an XML instance (because they don't have XML element names). 
<javax.xml.bind.annotation|XmlElementRef ad61f12b> Example 2: XML Schema Susbstitution group support The following example shows the annotations for XML Schema substitution groups. 
<javax.xml.bind.annotation|XmlElementRef 9d21e5be> The annotations and the ObjectFactory are derived from the schema. 
<javax.xml.bind.annotation|XmlElementRef 8d3dd772> &#64;XmlElement class Math { // The value of {@link #type()}is // JAXBElement.class , which indicates the XML // element name ObjectFactory - in general a class marked // with &#64;XmlRegistry. 
<javax.xml.bind.annotation|XmlElementRef 5a70a4a5> (See ObjectFactory below) // // The {@link #name()} is "operator", a pointer to a // factory method annotated with a // {@link XmlElementDecl} with the name "operator". 
<javax.xml.bind.annotation|XmlElementRef a5afac1b> Since // "operator" is the head of a substitution group that // contains elements "add" and "sub" elements, "operator" // element can be substituted in an instance document by // elements "add" or "sub". 
<javax.xml.bind.annotation|XmlElementRef 941efaec> At runtime, JAXBElement // instance contains the element name that has been // substituted in the XML document. 
<javax.xml.bind.annotation|XmlElementRef e38ece59> // &#64;XmlElementRef(type=JAXBElement.class,name="operator") JAXBElement&lt;? extends Operator> term; } &#64;XmlRegistry class ObjectFactory { &#64;XmlElementDecl(name="operator") JAXBElement&lt;Operator> createOperator(Operator o) {...} &#64;XmlElementDecl(name="add",substitutionHeadName="operator") JAXBElement&lt;Operator> createAdd(Operator o) {...} &#64;XmlElementDecl(name="sub",substitutionHeadName="operator") JAXBElement&lt;Operator> createSub(Operator o) {...} } class Operator { ... } Thus, the following code fragment Math m = new Math(); m.term = new ObjectFactory().createAdd(new Operator()); marshal(m); will produce the following XML output: &lt;math> &lt;add>...&lt;/add> &lt;/math> . 
<javax.xml.bind.annotation|XmlElementRef.type() 602005c1> The Java type being referenced. 
<javax.xml.bind.annotation|XmlElementRef.type() 5a6b609f> If the value is DEFAULT.class, the type is inferred from the the type of the JavaBean property. 
<javax.xml.bind.annotation|XmlElementRef.namespace() b13bf957> This parameter and {@link #name()} are used to determine the XML element for the JavaBean property. 
<javax.xml.bind.annotation|XmlElementRef.namespace() 9d75f64d> If type() is JAXBElement.class , then namespace() and name() point to a factory method with {@link XmlElementDecl}. 
<javax.xml.bind.annotation|XmlElementRef.namespace() a4ba088b> The XML element name is the element name from the factory method's {@link XmlElementDecl} annotation or if an element from its substitution group (of which it is a head element) has been substituted in the XML document, then the element name is from the {@link XmlElementDecl} on the substituted element. 
<javax.xml.bind.annotation|XmlElementRef.namespace() 14c4f7c0> If {@link #type()} is not JAXBElement.class, then the XML element name is the XML element name statically associated with the type using the annotation {@link XmlRootElement} on the type. 
<javax.xml.bind.annotation|XmlElementRef.namespace() 97c591b4> If the type is not annotated with an {@link XmlElementDecl}, then it is an error. 
<javax.xml.bind.annotation|XmlElementRef.namespace() 4f187e40> If type() is not JAXBElement.class, then this value must be "". 
<javax.xml.bind.annotation|XmlElementRef.DEFAULT 5825b0e2> Used in {@link XmlElementRef#type()} to signal that the type be inferred from the signature of the property. 
<javax.xml.bind.annotation|XmlElementDecl d41f9c3b> Maps a factory method to a XML element. 
<javax.xml.bind.annotation|XmlElementDecl 7a7dbf7b> Usage The annotation creates a mapping between an XML schema element declaration and a element factory method that returns a JAXBElement instance representing the element declaration. 
<javax.xml.bind.annotation|XmlElementDecl 733450cf> Typically, the element factory method is generated (and annotated) from a schema into the ObjectFactory class in a Java package that represents the binding of the element declaration's target namespace. 
<javax.xml.bind.annotation|XmlElementDecl 97c160a4> Thus, while the annotation syntax allows &#64;XmlElementDecl to be used on any method, semantically its use is restricted to annotation of element factory method. 
<javax.xml.bind.annotation|XmlElementDecl 680c4658> The usage is subject to the following constraints: The class containing the element factory method annotated with &#64;XmlElementDecl must be marked with {@link XmlRegistry}. 
<javax.xml.bind.annotation|XmlElementDecl 4c0888a9> The element factory method must take one parameter assignable to {@link Object}. 
<javax.xml.bind.annotation|XmlElementDecl 98c70a18> Example 1: Annotation on a factory method // Example: code fragment &#64;XmlRegistry class ObjectFactory { &#64;XmlElementDecl(name="foo") JAXBElement&lt;String> createFoo(String s) { ... } } string // Example: code fragment corresponding to XML input JAXBElement o = (JAXBElement)unmarshaller.unmarshal(aboveDocument); // print JAXBElement instance to show values System.out.println(o.getName()); // prints "{}foo" System.out.println(o.getValue()); // prints "string" System.out.println(o.getValue().getClass()); // prints "java.lang.String" Example 2: Element declaration with non local scope The following example illustrates the use of scope annotation parameter in binding of element declaration in schema derived code. 
<javax.xml.bind.annotation|XmlElementDecl d1ff0241> The following example may be replaced in a future revision of this javadoc. 
<javax.xml.bind.annotation|XmlElementDecl 132a5472> // Example: expected default binding class Pea { &#64;XmlElementRefs({ &#64;XmlElementRef(name="foo",type=JAXBElement.class) &#64;XmlElementRef(name="bar",type=JAXBElement.class) }) List&lt;JAXBElement&lt;String>> fooOrBar; } &#64;XmlRegistry class ObjectFactory { &#64;XmlElementDecl(scope=Pea.class,name="foo") JAXBElement createPeaFoo(String s); &#64;XmlElementDecl(scope=Pea.class,name="bar") JAXBElement createPeaBar(String s); &#64;XmlElementDecl(name="foo") JAXBElement createFoo(Integer i); } Without scope createFoo and createPeaFoo would become ambiguous since both of them map to a XML schema element with the same local name "foo". 
<javax.xml.bind.annotation|XmlElementDecl.scope() 4ccaf4ac> scope of the mapping. 
<javax.xml.bind.annotation|XmlElementDecl.scope() 203eb179> If this is not {@link XmlElementDecl.GLOBAL}, then this element declaration mapping is only active within the specified class. 
<javax.xml.bind.annotation|XmlElementDecl.namespace() 16e2c10a> namespace name of the XML element. 
<javax.xml.bind.annotation|XmlElementDecl.namespace() ec65777e> If the value is "##default", then the value is the namespace name for the package of the class containing this factory method. 
<javax.xml.bind.annotation|XmlElementDecl.name() d821fa58> local name of the XML element. 
<javax.xml.bind.annotation|XmlElementDecl.name() 13c0da34> Note to reviewers: There is no default name; since the annotation is on a factory method, it is not clear that the method name can be derived from the factory method name. 
<javax.xml.bind.annotation|XmlElementDecl.substitutionHeadNamespace() 6bd57e16> namespace name of a substitution group's head XML element. 
<javax.xml.bind.annotation|XmlElementDecl.substitutionHeadNamespace() b21f6cfe> This specifies the namespace name of the XML element whose local name is specified by substitutionHeadName(). 
<javax.xml.bind.annotation|XmlElementDecl.substitutionHeadNamespace() 4d350338> If susbtitutionHeadName() is "", then this value can only be "##default". 
<javax.xml.bind.annotation|XmlElementDecl.substitutionHeadNamespace() 6420028d> But the value is ignored since since this element is not part of susbtitution group when the value of susbstitutionHeadName() is "". 
<javax.xml.bind.annotation|XmlElementDecl.substitutionHeadNamespace() 8ef44949> If susbtitutionHeadName() is not "" and the value is "##default", then the namespace name is the namespace name to which the package of the containing class, marked with {@link XmlRegistry }, is mapped. 
<javax.xml.bind.annotation|XmlElementDecl.substitutionHeadNamespace() 81e2f2a7> If susbtitutionHeadName() is not "" and the value is not "##default", then the value is the namespace name. 
<javax.xml.bind.annotation|XmlElementDecl.substitutionHeadName() 98f3d0e6> XML local name of a substitution group's head element. 
<javax.xml.bind.annotation|XmlElementDecl.substitutionHeadName() aa2082d0> If the value is "", then this element is not part of any substitution group. 
<javax.xml.bind.annotation|XmlElementDecl.defaultValue() 342d1ea0> Default value of this element. 
<javax.xml.bind.annotation|XmlElementDecl.defaultValue() 8c07ef8> The ' ' value specified as a default of this annotation element is used as a poor-man's substitute for null to allow implementations to recognize the 'no default value' state. 
<javax.xml.bind.annotation|XmlElementDecl.GLOBAL 7a030ccc> Used in {@link XmlElementDecl#scope()} to signal that the declaration is in the global scope. 
<javax.xml.bind.annotation|XmlElement 144e9992> Maps a JavaBean property to a XML element derived from property name. 
<javax.xml.bind.annotation|XmlElement d0fca91a> Usage @XmlElement annotation can be used with the following program elements: a JavaBean property non static, non transient field within {@link XmlElements} The usage is subject to the following constraints: This annotation can be used with following annotations: {@link XmlID}, {@link XmlIDREF}, {@link XmlList}, {@link XmlSchemaType}, {@link XmlValue}, {@link XmlAttachmentRef}, {@link XmlMimeType}, {@link XmlInlineBinaryData}, {@link XmlElementWrapper}, {@link XmlJavaTypeAdapter} if the type of JavaBean property is a collection type of array, an indexed property, or a parameterized list, and this annotation is used with {@link XmlElements} then, @XmlElement.type() must be DEFAULT.class since the collection item type is already known. 
<javax.xml.bind.annotation|XmlElement 747ccacd> A JavaBean property, when annotated with @XmlElement annotation is mapped to a local element in the XML Schema complex type to which the containing class is mapped. 
<javax.xml.bind.annotation|XmlElement 2ba267ed> Example 1: Map a public non static non final field to local element //Example: Code fragment public class USPrice { &#64;XmlElement(name="itemprice") public java.math.BigDecimal price; } &lt;!-- Example: Local XML Schema element --> &lt;xs:complexType name="USPrice"/> &lt;xs:sequence> &lt;xs:element name="itemprice" type="xs:decimal" minOccurs="0"/> &lt;/sequence> &lt;/xs:complexType> Example 2: Map a field to a nillable element. 
<javax.xml.bind.annotation|XmlElement 935ca55f> //Example: Code fragment public class USPrice { &#64;XmlElement(nillable=true) public java.math.BigDecimal price; } &lt;!-- Example: Local XML Schema element --> &lt;xs:complexType name="USPrice"> &lt;xs:sequence> &lt;xs:element name="price" type="xs:decimal" nillable="true" minOccurs="0"/> &lt;/sequence> &lt;/xs:complexType> Example 3: Map a field to a nillable, required element. 
<javax.xml.bind.annotation|XmlElement 1e175117> //Example: Code fragment public class USPrice { &#64;XmlElement(nillable=true, required=true) public java.math.BigDecimal price; } &lt;!-- Example: Local XML Schema element --> &lt;xs:complexType name="USPrice"> &lt;xs:sequence> &lt;xs:element name="price" type="xs:decimal" nillable="true" minOccurs="1"/> &lt;/sequence> &lt;/xs:complexType> Example 4: Map a JavaBean property to an XML element with anonymous type. 
<javax.xml.bind.annotation|XmlElement e4fc9aa9> See Example 6 in @{@link XmlType}. 
<javax.xml.bind.annotation|XmlElement.name() 9334a6d8> Name of the XML Schema element. 
<javax.xml.bind.annotation|XmlElement.name() 762831f9> If the value is "##default", then element name is derived from the JavaBean property name. 
<javax.xml.bind.annotation|XmlElement.nillable() c7631b3f> Customize the element declaration to be nillable. 
<javax.xml.bind.annotation|XmlElement.nillable() ac71a88d> If nillable() is true, then the JavaBean property is mapped to a XML Schema nillable element declaration. 
<javax.xml.bind.annotation|XmlElement.required() 1f36a3ca> Customize the element declaration to be required. 
<javax.xml.bind.annotation|XmlElement.required() 1f628bb1> If required() is true, then Javabean property is mapped to an XML schema element declaration with minOccurs="1". 
<javax.xml.bind.annotation|XmlElement.required() 7a458791> maxOccurs is "1" for a single valued property and "unbounded" for a multivalued property. 
<javax.xml.bind.annotation|XmlElement.required() fccd3715> If required() is false, then the Javabean property is mapped to XML Schema element declaration with minOccurs="0". 
<javax.xml.bind.annotation|XmlElement.namespace() 2566bade> XML target namespace of the XML Schema element. 
<javax.xml.bind.annotation|XmlElement.namespace() dcf84344> If the value is "##default", then the namespace is determined as follows: If the enclosing package has {@link XmlSchema} annotation, and its {@link XmlSchema#elementFormDefault() elementFormDefault} is {@link XmlNsForm#QUALIFIED QUALIFIED}, then the namespace of the enclosing class. 
<javax.xml.bind.annotation|XmlElement.namespace() 99d85e5b> Otherwise "" (which produces unqualified element in the default namespace. 
<javax.xml.bind.annotation|XmlElement.defaultValue() 342d1ea0> Default value of this element. 
<javax.xml.bind.annotation|XmlElement.defaultValue() 8c07ef8> The ' ' value specified as a default of this annotation element is used as a poor-man's substitute for null to allow implementations to recognize the 'no default value' state. 
<javax.xml.bind.annotation|XmlElement.type() 1297fc03> The Java class being referenced. 
<javax.xml.bind.annotation|XmlElement.DEFAULT 134070d6> Used in {@link XmlElement#type()} to signal that the type be inferred from the signature of the property. 
<javax.xml.bind.annotation|XmlAttribute 281176d0>  Maps a JavaBean property to a XML attribute. 
<javax.xml.bind.annotation|XmlAttribute 3a20ad4e> Usage The @XmlAttribute annotation can be used with the following program elements: JavaBean property field A static final field is mapped to a XML fixed attribute. 
<javax.xml.bind.annotation|XmlAttribute 21c9934a> See "Package Specification" in javax.xml.bind.package javadoc for additional common information. 
<javax.xml.bind.annotation|XmlAttribute 82bb746d> The usage is subject to the following constraints: If type of the field or the property is a collection type, then the collection item type must be mapped to schema simple type. 
<javax.xml.bind.annotation|XmlAttribute 91986a48> // Examples &#64;XmlAttribute List&lt;Integer> items; //legal &#64;XmlAttribute List&lt;Bar> foo; // illegal if Bar does not map to a schema simple type If the type of the field or the property is a non collection type, then the type of the property or field must map to a simple schema type. 
<javax.xml.bind.annotation|XmlAttribute df25465> // Examples &#64;XmlAttribute int foo; // legal &#64;XmlAttribute Foo foo; // illegal if Foo does not map to a schema simple type This annotation can be used with the following annotations: {@link XmlID}, {@link XmlIDREF}, {@link XmlList}, {@link XmlSchemaType}, {@link XmlValue}, {@link XmlAttachmentRef}, {@link XmlMimeType}, {@link XmlInlineBinaryData}, {@link javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter}. 
<javax.xml.bind.annotation|XmlAttribute 5db4cdab> Example 1: Map a JavaBean property to an XML attribute. 
<javax.xml.bind.annotation|XmlAttribute cbaf4a34> //Example: Code fragment public class USPrice { &#64;XmlAttribute public java.math.BigDecimal getPrice() {...} ; public void setPrice(java.math.BigDecimal ) {...}; } &lt;!-- Example: XML Schema fragment --> &lt;xs:complexType name="USPrice"> &lt;xs:sequence> &lt;/xs:sequence> &lt;xs:attribute name="price" type="xs:decimal"/> &lt;/xs:complexType> Example 2: Map a JavaBean property to an XML attribute with anonymous type. 
<javax.xml.bind.annotation|XmlAttribute 3ed804ea> See Example 7 in @{@link XmlType}. 
<javax.xml.bind.annotation|XmlAttribute 930d3c87> Example 3: Map a JavaBean collection property to an XML attribute. 
<javax.xml.bind.annotation|XmlAttribute 98c5b68c> // Example: Code fragment class Foo { ... &#64;XmlAttribute List&lt;Integer> items; } &lt;!-- Example: XML Schema fragment --> &lt;xs:complexType name="foo"> ... &lt;xs:attribute name="items"> &lt;xs:simpleType> &lt;xs:list itemType="xs:int"/> &lt;/xs:simpleType> &lt;/xs:complexType> . 
<javax.xml.bind.annotation|XmlAttribute.name() d3d42c13> Name of the XML Schema attribute. 
<javax.xml.bind.annotation|XmlAttribute.name() b1aaf812> By default, the XML Schema attribute name is derived from the JavaBean property name. 
<javax.xml.bind.annotation|XmlAttribute.required() 5f1c572d> Specifies if the XML Schema attribute is optional or required. 
<javax.xml.bind.annotation|XmlAttribute.required() 6fc9b651> If true, then the JavaBean property is mapped to a XML Schema attribute that is required. 
<javax.xml.bind.annotation|XmlAttribute.required() 155494d1> Otherwise it is mapped to a XML Schema attribute that is optional. 
<javax.xml.bind.annotation|XmlAttribute.namespace() e5a411c6> Specifies the XML target namespace of the XML Schema attribute. 
<javax.xml.bind.annotation|XmlAttachmentRef 206ae66d> Marks a field/property that its XML form is a uri reference to mime content. 
<javax.xml.bind.annotation|XmlAttachmentRef 9f0f46d6> The mime content is optimally stored out-of-line as an attachment. 
<javax.xml.bind.annotation|XmlAttachmentRef fc75992a> A field/property must always map to the {@link DataHandler} class. 
<javax.xml.bind.annotation|XmlAttachmentRef 6aca564a> Usage &#64;{@link XmlRootElement} class Foo { &#64;{@link XmlAttachmentRef} &#64;{@link XmlAttribute} {@link DataHandler} data; &#64;{@link XmlAttachmentRef} &#64;{@link XmlElement} {@link DataHandler} body; } The above code maps to the following XML: The above binding supports WS-I AP 1.0 WS-I Attachments Profile Version 1.0.. 
<javax.xml.bind.annotation|XmlAnyElement 1d718316> Maps a JavaBean property to XML infoset representation and/or JAXB element. 
<javax.xml.bind.annotation|XmlAnyElement 65688b77> This annotation serves as a "catch-all" property while unmarshalling xml content into a instance of a JAXB annotated class. 
<javax.xml.bind.annotation|XmlAnyElement b967152f> It typically annotates a multi-valued JavaBean property, but it can occur on single value JavaBean property. 
<javax.xml.bind.annotation|XmlAnyElement 2ffb9e3a> During unmarshalling, each xml element that does not match a static &#64;XmlElement or &#64;XmlElementRef annotation for the other JavaBean properties on the class, is added to this "catch-all" property. 
<javax.xml.bind.annotation|XmlAnyElement 584f040d> Usages: &#64;XmlAnyElement public {@link Element}[] others; // Collection of {@link Element} or JAXB elements. 
<javax.xml.bind.annotation|XmlAnyElement b30806a7> &#64;XmlAnyElement(lax="true") public {@link Object}[] others; &#64;XmlAnyElement private List&lt;{@link Element}> nodes; &#64;XmlAnyElement private {@link Element} node; Restriction usage constraints This annotation is mutually exclusive with {@link XmlElement}, {@link XmlAttribute}, {@link XmlValue}, {@link XmlElements}, {@link XmlID}, and {@link XmlIDREF}. 
<javax.xml.bind.annotation|XmlAnyElement 2ec0968> There can be only one {@link XmlAnyElement} annotated JavaBean property in a class and its super classes. 
<javax.xml.bind.annotation|XmlAnyElement 7b9d676b> Relationship to other annotations This annotation can be used with {@link XmlJavaTypeAdapter}, so that users can map their own data structure to DOM, which in turn can be composed into XML. 
<javax.xml.bind.annotation|XmlAnyElement 40beb563> This annotation can be used with {@link XmlMixed} like this: // List of java.lang.String or DOM nodes. 
<javax.xml.bind.annotation|XmlAnyElement 5ad8e3c8> &#64;XmlAnyElement &#64;XmlMixed List&lt;Object> others; Schema To Java example The following schema would produce the following Java class: class Foo { int a; int b; &#64;{@link XmlAnyElement} List&lt;Element> any; } It can unmarshal instances like 1 // this will be bound to DOM, because unmarshalling is orderless 3 5 // this will be bound to DOM, because the annotation doesn't remember namespaces. 
<javax.xml.bind.annotation|XmlAnyElement aa07e848> The following schema would produce the following Java class: class Bar extends Foo { int c; // Foo.getAny() also represents wildcard content for type definition bar. 
<javax.xml.bind.annotation|XmlAnyElement 174cf76d> } It can unmarshal instances like 1 // this will be bound to DOM, because unmarshalling is orderless 3 5 // this now goes to Bar.c // this will go to Foo.any Using {@link XmlAnyElement} with {@link XmlElementRef} The {@link XmlAnyElement} annotation can be used with {@link XmlElementRef}s to designate additional elements that can participate in the content tree. 
<javax.xml.bind.annotation|XmlAnyElement 82b7f503> The following schema would produce the following Java class: class Foo { &#64;{@link XmlAnyElement}(lax="true") &#64;{@link XmlElementRefs}({ &#64;{@link XmlElementRef}(name="a", type="JAXBElement.class") &#64;{@link XmlElementRef}(name="b", type="JAXBElement.class") }) {@link List}&lt;{@link Object}> others; } &#64;XmlRegistry class ObjectFactory { ... &#64;XmlElementDecl(name = "a", namespace = "", scope = Foo.class) {@link JAXBElement}&lt;Integer> createFooA( Integer i ) { ... } &#64;XmlElementDecl(name = "b", namespace = "", scope = Foo.class) {@link JAXBElement}&lt;Integer> createFooB( Integer i ) { ... } It can unmarshal instances like 1 // this will unmarshal to a {@link JAXBElement} instance whose value is 1. 
<javax.xml.bind.annotation|XmlAnyElement 59f0bbb3> // this will unmarshal to a DOM {@link Element}. 
<javax.xml.bind.annotation|XmlAnyElement b03c7f3> 3 // this will unmarshal to a {@link JAXBElement} instance whose value is 1. 
<javax.xml.bind.annotation|XmlAnyElement 1de2d09> W3C XML Schema "lax" wildcard emulation The lax element of the annotation enables the emulation of the "lax" wildcard semantics. 
<javax.xml.bind.annotation|XmlAnyElement d9ccb514> For example, when the Java source code is annotated like this: &#64;{@link XmlRootElement} class Foo { &#64;XmlAnyElement(lax=true) public {@link Object}[] others; } then the following document will unmarshal like this: Foo foo = unmarshal(); // 1 for 'unknown', another for 'foo' assert foo.others.length==2; // 'unknown' unmarshals to a DOM element assert foo.others[0] instanceof Element; // because of lax=true, the 'foo' element eagerly // unmarshals to a Foo object. 
<javax.xml.bind.annotation|XmlAnyElement a790d9b6> assert foo.others[1] instanceof Foo; . 
<javax.xml.bind.annotation|XmlAnyElement.lax() da5372e8> Controls the unmarshaller behavior when it sees elements known to the current {@link JAXBContext}. 
<javax.xml.bind.annotation|XmlAnyElement.lax() cdbf4e19> When false If false, all the elements that match the property will be unmarshalled to DOM, and the property will only contain DOM elements. 
<javax.xml.bind.annotation|XmlAnyElement.lax() 81162443> When true If true, when an element matches a property marked with {@link XmlAnyElement} is known to {@link JAXBContext} (for example, there's a class with {@link XmlRootElement} that has the same tag name, or there's {@link XmlElementDecl} that has the same tag name), the unmarshaller will eagerly unmarshal this element to the JAXB object, instead of unmarshalling it to DOM. 
<javax.xml.bind.annotation|XmlAnyElement.lax() 6c67e160> Additionally, if the element is unknown but it has a known xsi:type, the unmarshaller eagerly unmarshals the element to a {@link JAXBElement}, with the unknown element name and the JAXBElement value is set to an instance of the JAXB mapping of the known xsi:type. 
<javax.xml.bind.annotation|XmlAnyElement.lax() a1a401df> As a result, after the unmarshalling, the property can become heterogeneous; it can have both DOM nodes and some JAXB objects at the same time. 
<javax.xml.bind.annotation|XmlAnyElement.lax() a5703bbf> This can be used to emulate the "lax" wildcard semantics of the W3C XML Schema. 
<javax.xml.bind.annotation|XmlAnyElement.value() 3a6de0aa> Specifies the {@link DomHandler} which is responsible for actually converting XML from/to a DOM-like data structure. 
<javax.xml.bind.annotation|XmlAnyAttribute 85726875>  Maps a JavaBean property to a map of wildcard attributes. 
<javax.xml.bind.annotation|XmlAnyAttribute 3945cc3c> Usage The &#64;XmlAnyAttribute annotation can be used with the following program elements: JavaBean property non static, non transient field See "Package Specification" in javax.xml.bind.package javadoc for additional common information. 
<javax.xml.bind.annotation|XmlAnyAttribute 987859d> The usage is subject to the following constraints: At most one field or property in a class can be annotated with &#64;XmlAnyAttribute. 
<javax.xml.bind.annotation|XmlAnyAttribute 30e204e5> The type of the property or the field must java.util.Map While processing attributes to be unmarshalled into a value class, each attribute that is not statically associated with another JavaBean property, via {@link XmlAttribute}, is entered into the wildcard attribute map represented by {@link Map}&lt;{@link QName},{@link Object}>. 
<javax.xml.bind.annotation|XmlAnyAttribute 4fd7faf7> The attribute QName is the map's key. 
<javax.xml.bind.annotation|XmlAnyAttribute eaff9c0a> The key's value is the String value of the attribute. 
<javax.xml.bind.annotation|XmlAccessType 575ae438> Used by XmlAccessorType to control serialization of fields or properties. 
<javax.xml.bind.annotation|XmlAccessType.PROPERTY 93c3d7bb> Every getter/setter pair in a JAXB-bound class will be automatically bound to XML, unless annotated by {@link XmlTransient}. 
<javax.xml.bind.annotation|XmlAccessType.PROPERTY bca1a92f> Fields are bound to XML only when they are explicitly annotated by some of the JAXB annotations. 
<javax.xml.bind.annotation|XmlAccessType.FIELD 2919401b> Every non static, non transient field in a JAXB-bound class will be automatically bound to XML, unless annotated by {@link XmlTransient}. 
<javax.xml.bind.annotation|XmlAccessType.FIELD 840e0568> Getter/setter pairs are bound to XML only when they are explicitly annotated by some of the JAXB annotations. 
<javax.xml.bind.annotation|XmlAccessType.PUBLIC_MEMBER 8fdc46e6> Every public getter/setter pair and every public field will be automatically bound to XML, unless annotated by {@link XmlTransient}. 
<javax.xml.bind.annotation|XmlAccessType.PUBLIC_MEMBER b1723a79> Fields or getter/setter pairs that are private, protected, or defaulted to package-only access are bound to XML only when they are explicitly annotated by the appropriate JAXB annotations. 
<javax.xml.bind.annotation|XmlAccessType.NONE 5e9a980f> None of the fields or properties is bound to XML unless they are specifically annotated with some of the JAXB annotations. 
<javax.xml.bind.annotation|XmlAccessorType a8156b21>  Controls whether fields or Javabean properties are serialized by default. 
<javax.xml.bind.annotation|XmlAccessorType 78700ea1> Usage @XmlAccessorType annotation can be used with the following program elements: package a top level class See "Package Specification" in javax.xml.bind.package javadoc for additional common information. 
<javax.xml.bind.annotation|XmlAccessorType 63cb2073> This annotation provides control over the default serialization of properties and fields in a class. 
<javax.xml.bind.annotation|XmlAccessorType cd0163c1> The annotation @XmlAccessorType on a package applies to all classes in the package. 
<javax.xml.bind.annotation|XmlAccessorType 90553072> The following inheritance semantics apply: If there is a @XmlAccessorType on a class, then it is used. 
<javax.xml.bind.annotation|XmlAccessorType 4deadc73> Otherwise, if a @XmlAccessorType exists on one of its super classes, then it is inherited. 
<javax.xml.bind.annotation|XmlAccessorType 730ae14> Otherwise, the @XmlAccessorType on a package is inherited. 
<javax.xml.bind.annotation|XmlAccessorType e5bf1963> Defaulting Rules: By default, if @XmlAccessorType on a package is absent, then the following package level annotation is assumed. 
<javax.xml.bind.annotation|XmlAccessorType 6ad32881> &#64;XmlAccessorType(XmlAccessType.PUBLIC_MEMBER) By default, if @XmlAccessorType on a class is absent, and none of its super classes is annotated with @XmlAccessorType, then the following default on the class is assumed: &#64;XmlAccessorType(XmlAccessType.PUBLIC_MEMBER) This annotation can be used with the following annotations: {@link XmlType}, {@link XmlRootElement}, {@link XmlAccessorOrder}, {@link XmlSchema}, {@link XmlSchemaType}, {@link XmlSchemaTypes}, , {@link XmlJavaTypeAdapter}. 
<javax.xml.bind.annotation|XmlAccessorType 2fa36f53> It can also be used with the following annotations at the package level: {@link XmlJavaTypeAdapter}. 
<javax.xml.bind.annotation|XmlAccessorType.value() 607ecf6b> Specifies whether fields or properties are serialized. 
<javax.xml.bind.annotation|XmlAccessorOrder 9586e998>  Controls the ordering of fields and properties in a class. 
<javax.xml.bind.annotation|XmlAccessorOrder 2e2f8c> Usage @XmlAccessorOrder annotation can be used with the following program elements: package a top level class See "Package Specification" in javax.xml.bind.package javadoc for additional common information. 
<javax.xml.bind.annotation|XmlAccessorOrder 259da702> The annotation @XmlAccessorOrder on a package applies to all classes in a package. 
<javax.xml.bind.annotation|XmlAccessorOrder 3272dee7> The following inheritance semantics apply: If there is a @XmlAccessorOrder on a class, then it is used. 
<javax.xml.bind.annotation|XmlAccessorOrder caa5d55e> Otherwise, if a @XmlAccessorOrder exists on one of its super classes, then it is inherited. 
<javax.xml.bind.annotation|XmlAccessorOrder c218dcff> Otherwise, the @XmlAccessorOrder on a package is inherited. 
<javax.xml.bind.annotation|XmlAccessorOrder 390bef98> Defaulting Rules: By default, if @XmlAccessorOrder on a package is absent, then the following package level annotation is assumed. 
<javax.xml.bind.annotation|XmlAccessorOrder e72bddd> &#64;XmlAccessorType(XmlAccessOrder.UNDEFINED) By default, if @XmlAccessorOrder on a class is absent and none of super classes is annotated with XmlAccessorOrder , then the following default on the class is assumed: &#64;XmlAccessorType(XmlAccessOrder.UNDEFINED) This annotation can be used with the following annotations: {@link XmlType}, {@link XmlRootElement}, {@link XmlAccessorType}, {@link XmlSchema}, {@link XmlSchemaType}, {@link XmlSchemaTypes}, , {@link XmlJavaTypeAdapter}. 
<javax.xml.bind.annotation|XmlAccessorOrder 2fa36f53> It can also be used with the following annotations at the package level: {@link XmlJavaTypeAdapter}. 
<javax.xml.bind.annotation|XmlAccessOrder 2992f560> Used by XmlAccessorOrder to control the ordering of properties and fields in a JAXB bound class. 
<javax.xml.bind.annotation|XmlAccessOrder.UNDEFINED f404839b> The ordering of fields and properties in a class is undefined. 
<javax.xml.bind.annotation|XmlAccessOrder.ALPHABETICAL e43b894a> The ordering of fields and properties in a class is in alphabetical order as determined by the method java.lang.String.compareTo(String anotherString). 
<javax.xml.bind.annotation|W3CDomHandler d280ffed> {@link DomHandler} implementation for W3C DOM (org.w3c.dom package.). 
<javax.xml.bind.annotation|W3CDomHandler.W3CDomHandler() 4458f205> Default constructor. 
<javax.xml.bind.annotation|W3CDomHandler.W3CDomHandler() 88006bae> It is up to a JAXB provider to decide which DOM implementation to use or how that is configured. 
<javax.xml.bind.annotation|W3CDomHandler.W3CDomHandler(javax.xml.parsers.DocumentBuilder) 718531e8> Constructor that allows applications to specify which DOM implementation to be used. 
<javax.xml.bind.annotation|DomHandler 340dbb67> Converts an element (and its descendants) from/to DOM (or similar) representation. 
<javax.xml.bind.annotation|DomHandler a4f45ece> Implementations of this interface will be used in conjunction with {@link XmlAnyElement} annotation to map an element of XML into a representation of infoset such as W3C DOM. 
<javax.xml.bind.annotation|DomHandler d20ea4d5> Implementations hide how a portion of XML is converted into/from such DOM-like representation, allowing JAXB providers to work with arbitrary such library. 
<javax.xml.bind.annotation|DomHandler 315ca7a0> This interface is intended to be implemented by library writers and consumed by JAXB providers. 
<javax.xml.bind.annotation|DomHandler 5570ef5d> None of those methods are intended to be called from applications. 
<javax.xml.bind.annotation|DomHandler.createUnmarshaller(javax.xml.bind.ValidationEventHandler) ca25a971> When a JAXB provider needs to unmarshal a part of a document into an infoset representation, it first calls this method to create a {@link Result} object. 
<javax.xml.bind.annotation|DomHandler.createUnmarshaller(javax.xml.bind.ValidationEventHandler) 3af3b7dd> A JAXB provider will then send a portion of the XML into the given result. 
<javax.xml.bind.annotation|DomHandler.createUnmarshaller(javax.xml.bind.ValidationEventHandler) f201c70> Such a portion always form a subtree of the whole XML document rooted at an element. 
<javax.xml.bind.annotation|DomHandler.createUnmarshaller(javax.xml.bind.ValidationEventHandler) 888a09c7> @return:null if the operation fails. 
<javax.xml.bind.annotation|DomHandler.createUnmarshaller(javax.xml.bind.ValidationEventHandler) 44b160a0> The error must have been reported to the error handler. 
<javax.xml.bind.annotation|DomHandler.getElement(javax.xml.transform.Result) 24d0406d> Once the portion is sent to the {@link Result}. 
<javax.xml.bind.annotation|DomHandler.getElement(javax.xml.transform.Result) df7d33d5> This method is called by a JAXB provider to obtain the unmarshalled element representation. 
<javax.xml.bind.annotation|DomHandler.getElement(javax.xml.transform.Result) 39c50591> Multiple invocations of this method may return different objects. 
<javax.xml.bind.annotation|DomHandler.getElement(javax.xml.transform.Result) 6d01d42e> This method can be invoked only when the whole sub-tree are fed to the {@link Result} object. 
<javax.xml.bind.annotation|DomHandler.getElement(javax.xml.transform.Result) 888a09c7> @return:null if the operation fails. 
<javax.xml.bind.annotation|DomHandler.getElement(javax.xml.transform.Result) 44b160a0> The error must have been reported to the error handler. 
<javax.xml.bind.annotation|DomHandler.marshal(java.lang.Object,javax.xml.bind.ValidationEventHandler) 229b69f6> This method is called when a JAXB provider needs to marshal an element to XML. 
<javax.xml.bind.annotation|DomHandler.marshal(java.lang.Object,javax.xml.bind.ValidationEventHandler) 810b0e5d> If non-null, the returned {@link Source} must contain a whole document rooted at one element, which will then be weaved into a bigger document that the JAXB provider is marshalling. 
<javax.xml.bind.annotation|DomHandler.marshal(java.lang.Object,javax.xml.bind.ValidationEventHandler) fad0d1a8> @return:null if there was an error. 
<javax.xml.bind.annotation|DomHandler.marshal(java.lang.Object,javax.xml.bind.ValidationEventHandler) 74f6599b> The error should have been reported to the handler. 
