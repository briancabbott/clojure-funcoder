This is a project for Clojure Coding. The idea is the pursuit of excellence in Clojure.
Identified knowledge targets that might arrive one at excellence are as follows:  

High-Level:
   - Mathematical Principles (Foundation)
   - Computer Science Principles (Foundation)
   - Functional Programming Theory and Principles (Foundation)
   - The Clojure Language
      - Base Clojure Concepts (in idiomatic terms where repetetive)
      - Core API
      - Extension APIs (everything of clojure.org not part of the primary distribution)
      - Advanced programming (i.e. Macros, etc)
      - Operational and Runtime Architecture
      - Internal Architecture and Programming model (how to extend the language, internally)
   - Clojure Systems
      - Data operations
         - Datalog
         - Datomic (free, prem, cloud, ions)
         - Crux
      - Production Application Coding:
         - Containers
         - Cloud Applications
         - Micro-Services
      - Web Application Development
         - ClojureScript
         - UI's




Itemized-Level

- Mathematical Principles (Foundation)
- Computer Science Principles (Foundation)
  - Data Structures and Algorithms:
   - Sorting-Algorithms
      - Bubble-Sort
      - Bucket-Sort
      - Column-Sort
      - Counting-Sort
      - Heapsort
      - Insertion-Sort
      - Merge-Sort
      - Quicksort
      - Radix-Sort

   - Searching-Algorithms
      - Linear Search
      - Random-Search
      - Deterministic-Search
      - Scramble-Search
      - Compact-List-Search

   - Data-Structures
      - Set
      - Dynamic-Set
         - Search
         - Insert
         - Delete
         - Minimum
         - Maximum
         - Successor
         - Predecessor

      - Heap
      - Max-Heap
      - Min-Heap
      - Mergeable-Heap

      - Stack
         - Push
         - Pop

      - Queue
      - Priority Queue
      - Max-Priority Queue
      - LIFO-Queue
      - FIFO-Queue
         - Enqueue
         - Dequeu

      - Linked-List
      - Singly-Linked-List
      - Doubly-Linked-List
      - Circularly-Linked-List
         - Allocate
         - Free
         - Search
         - Insert
         - Delete
         - Next
         - Back

      - Hash-Tables
      - Direct-Address-Tables
         - Direct-Address-Search
         - Direct-Address-Insert
         - Direct-Address-Delete
         - Chained-Hash-Insert
         - Chained-Hash-Search
         - Chained-Hash-Delete
         - Hash-Insert
         - Hash-Search
         - Hash-Delete
      - Hash-Functions
         - Open addressing (no hash-function)
         - Division method
         - Multiplication method
         - Universal hashing
         - Quadratic probing
         - Double hashing
         - Auxillary hash function

      - Trees
      - Binary-Search-Trees
      - Randomly-Built-Binary-Search-Tree
      - Radix-Tree      
         - Inorder-Tree-Walk
         - Tree-Search
         - Iterative-Tree-Search
         - Tree-Minimum
         - Tree-Maximum
         - Tree-Successor
         - Tree-Predecessor
         - Tree-Insert
         - Transplant
         - Tree-Delete
         - Left-Rotate
         - Right-Rotate
      - Red-Black-Tree
      - Relaxed-Red-Black-Tree
         - RB-Insert
         - RB-Insert-Fixup
         - RB-Transplant
         - RB-Delete
         - RB-Delete-Fixup
         - RB-Join
      - AVL Trees
         - Balance
         - AVL-Insert
      - Treap
         - Treap-Insert
      - Order-Statistic-Tree
         - OS-Select
         - OS-Rank
         - OS-Key-Rank
      - Interval-Trees
         - Interval-Insert
         - Interval-Delete
         - Interval-Search
         - Interval-Search-Exactly

      - Dynamic-Programming
      - Rod-Cutting
         - Cut-Rod
         - Memoized-Cut-Rod
         - Memoized-Cut-Rod-Aux
         - Bottom-Up-Cut-Rod
         - Extended-Bottom-Up-Cut-Rod
         - Print-Cut-Rod-Solution

      - Greedy Algorithms
      - Amortized-Analysis
         - Aggregate-Analysis
            - Push
            - Pop
            - MultiPop
            - Increment
         - Accounting Method
            - Push
            - Pop
            - MultiPop
         - Dynamic-Tables
            - Table-Expansion
               - Table-Insert
               - Table-Delete
          - Amortized weight-balanced-trees

       - Advanced Data-Structures
          Dynamic-Trees
          Splay-Trees
          Persistent
          Fusion-Trees
          Exponential-Search-Trees
          Dynamic-Graph-Data-Structures
          B-Trees

       - Graphs
          - Graph Representation
             - Adjacency List Representation
                - Sparse Graphs
             - Adjacency Matrix Representation
                - Dense Graphs
          - Graph Types/Structures/Shapes
             - Weigthed Graph
          - Algorithms
             - Breadth-First-Search
             - Depth-First-Search
                - DFS-Visit
             - Topological-Sort
             - Strongly-Connected-Components
             - Minimum-Spanning-Trees
                - Generic-Minimum-Spanning-Tree
                - MST-Kruskal
                - MST-Prim
                - MST-Reduce
                - Alternative Algorithms
                  - Maybe-MST-A
                  - Maybe-MST-B
                  - Maybe-MST-C
             - Shortest-Path Algorithms      
                - Traveling-Salesman-Problem
                - Traveling-Salesman-Problem-With-Nearest-Neighbor
                - Bellman-Ford-Algorithm
                - DAG-Shortest-Paths
                - Dijkstra
                - Kruskal's Algorithm

       - Matrix Algorithms
          - LUP-Solve
          - LU-Decomposition
          - LUP-Decomposition

       - Number-Theory Algorithms

       - NP-Completeness Algorithms

    - Find-Max-Crossing-Subarray
    - Find-Maximum-Subarray
    - Square-Matrix-Multiply
    - Hire-Assistant
    - Randomized-Hire-Assistant
    - Permute-by-Sorting
    - Randomize-in-Place
    - Permute-without-identity
    - Permute-with-all
    - Permute-by-cyclic
    - Random-Sample
    - On-Line-Maximum
    - Heap-Increase-Key
    - Partition
    - Randomized-Partition
    - Hoare-Partition
    - Randomized-Quicksort
    - Randomized-Select
    - Randomize-In-Place
    - Random-Sample
    - Permute-By-Sorting
    - Permute-Without-Identity
    - Permute-With-All
    - Permute-By-Cyclic
    - Online-Maximum
    - Matrix Algorithms
      - Square-Matrix-Multiply
      - Square-Matrix-Multiply-Recursive
    - Fibonacci Generating Function
- Functional Programming Theory and Principles (Foundation)
- The Clojure Language
   - Base Clojure Concepts (in idiomatic terms where repetetive)
   - Core API
   - Extension APIs (everything of clojure.org not part of the primary distribution)
   - Advanced programming (i.e. Macros, etc)
   - Operational and Runtime Architecture
   - Internal Architecture and Programming model (how to extend the language, internally)
- Clojure Systems
   - Data operations
      - Datalog
      - Datomic (free, prem, cloud, ions)
      - Crux
   - Production Application Coding:
      - Containers
      - Cloud Applications
      - Micro-Services
   - Web Application Development
      - ClojureScript
      - UI's







REPL Driving Coding

Debugging





Clojure
Clojure-Contrib
clojure.data.codec
ClojureCLR
ClojureScript

algo.generic
algo.monads
core.async
core.cache
core.contracts
core.incubator
core.logic
core.match
core.memoize
core.rrb-vector
core.typed
core.unify
data.avl
data.csv
data.finger-tree
data.fressian
data.generators
data.int-map
data.json
data.priority-map
data.xml
data.zip
java.classpath
java.data
java.jdbc
java.jmx
jvm.tools.analyzer
math.combinatorics
math.numeric-tower
test.benchmark
test.check
test.generative
tools.analyzer
tools.cli
tools.deps
tools.emitter.jvm
tools.logging
tools.macro
tools.namespace
tools.nrepl
tools.reader
tools.trace
